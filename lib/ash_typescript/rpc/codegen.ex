defmodule AshTypescript.Rpc.Codegen do
  @moduledoc """
  Generates TypeScript code for interacting with Ash resources via Rpc.
  """
  import AshTypescript.Codegen
  import AshTypescript.Filter
  import AshTypescript.Helpers

  def generate_typescript_types(otp_app, opts \\ []) do
    endpoint_process = Keyword.get(opts, :run_endpoint, "/rpc/run")
    endpoint_validate = Keyword.get(opts, :validate_endpoint, "/rpc/validate")

    resources_and_actions = get_rpc_resources_and_actions(otp_app)

    generate_full_typescript(
      resources_and_actions,
      endpoint_process,
      endpoint_validate,
      otp_app
    )
  end

  defp get_rpc_resources_and_actions(otp_app) do
    otp_app
    |> Ash.Info.domains()
    |> Enum.flat_map(fn domain ->
      # Get Rpc configuration from the domain
      rpc_config = AshTypescript.Rpc.Info.rpc(domain)

      Enum.flat_map(rpc_config, fn %{resource: resource, rpc_actions: rpc_actions} ->
        Enum.map(rpc_actions, fn rpc_action ->
          action = Ash.Resource.Info.action(resource, rpc_action.action)
          {resource, action, rpc_action}
        end)
      end)
    end)
  end

  defp generate_full_typescript(
         rpc_resources_and_actions,
         endpoint_process,
         endpoint_validate,
         otp_app
       ) do
    # Extract only the Rpc resources
    rpc_resources =
      otp_app
      |> Ash.Info.domains()
      |> Enum.flat_map(fn domain ->
        AshTypescript.Rpc.Info.rpc(domain)
        |> Enum.map(fn %{resource: r} -> r end)
      end)

    actions =
      otp_app
      |> Ash.Info.domains()
      |> Enum.flat_map(fn domain ->
        AshTypescript.Rpc.Info.rpc(domain)
        |> Enum.flat_map(fn %{resource: resource, rpc_actions: rpc_actions} ->
          Enum.map(rpc_actions, fn %{action: action} ->
            Ash.Resource.Info.action(resource, action)
          end)
        end)
      end)

    # Discover embedded resources and include them in schema generation
    embedded_resources = AshTypescript.Codegen.find_embedded_resources(rpc_resources)
    all_resources_for_schemas = rpc_resources ++ embedded_resources

    """
    // Generated by AshTypescript
    // Do not edit this file manually

    #{generate_ash_type_aliases(rpc_resources, actions)}

    #{generate_all_schemas_for_resources(all_resources_for_schemas, all_resources_for_schemas)}

    #{generate_filter_types(all_resources_for_schemas, all_resources_for_schemas)}

    #{generate_utility_types()}

    #{generate_helper_functions()}

    #{generate_rpc_functions(rpc_resources_and_actions, endpoint_process, endpoint_validate, otp_app, all_resources_for_schemas)}
    """
  end

  defp generate_utility_types do
    """
    // Utility Types
    type ResourceBase = {
      fields: Record<string, any>;
      relationships: Record<string, any>;
      complexCalculations: Record<string, any>;
      unions: Record<string, any>;
      __complexCalculationsInternal: Record<string, any>;
    };

    type UnifiedFieldSelection<Resource extends ResourceBase> =
      | keyof Resource["fields"]
      | {
          [K in keyof Resource["relationships"]]?: UnifiedFieldSelection<
            Resource["relationships"][K] extends { __resource: infer R }
            ? R extends ResourceBase ? R : never : never
          >[];
        }
      | {
          [K in keyof Resource["complexCalculations"]]?: Resource["__complexCalculationsInternal"][K] extends { __returnType: infer ReturnType }
            ? ReturnType extends ResourceBase
              ? {
                  args: Resource["complexCalculations"][K] extends { args: infer Args } ? Args : never;
                  fields: UnifiedFieldSelection<ReturnType>[];
                }
              : {
                  args: Resource["complexCalculations"][K] extends { args: infer Args } ? Args : never;
                }
            : never;
        }
      | {
          [K in keyof Resource["unions"]]?: (string | { [UnionMember: string]: UnifiedFieldSelection<any>[] })[];
        };


    // Separate field selection type (for fields and relationships only)
    type FieldSelection<Resource extends ResourceBase> =
      | keyof Resource["fields"]
      | {
          [K in keyof Resource["relationships"]]?: FieldSelection<
            Resource["relationships"][K] extends { __resource: infer R }
              ? R extends ResourceBase
                ? R
                : never
              : never
          >[];
        };

    // Helper to extract string fields from unified field selection
    type ExtractStringFields<Fields> = Fields extends readonly (infer U)[]
      ? U extends string
        ? U
        : never
      : never;

    // Utility type to convert union to intersection
    type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (k: infer I) => void ? I : never;

    // Process union field selection - extract only requested union members
    type ProcessUnionFieldSelection<UnionField, Selection> = 
      Selection extends (infer Item)[]
        ? Item extends string
          ? // Primitive union member - extract from union field
            UnionField extends Record<string, any>
              ? Item extends keyof UnionField
                ? { [K in Item]: UnionField[K] }
                : {}
              : {}
          : Item extends Record<string, any>
            ? // Complex union member with field selection
              {
                [K in keyof Item]: K extends keyof UnionField
                  ? UnionField[K] extends ResourceBase
                    ? InferResourceResult<UnionField[K], Item[K]>
                    : UnionField[K]
                  : never
              }
            : {}
        : {};

    // Process individual fields using schema keys as classifiers
    type ProcessField<Resource extends ResourceBase, Field> = 
      Field extends string 
        ? // String field - pick from fields schema
          Field extends keyof Resource["fields"]
            ? { [K in Field]: Resource["fields"][K] }
            : {}
        : Field extends Record<string, any>
          ? // Object field - use schema keys to classify
            {
              [K in keyof Field]: K extends keyof Resource["complexCalculations"]
                ? // Complex calculation - use internal schema for inference
                  Resource["__complexCalculationsInternal"][K] extends { __returnType: infer ReturnType }
                    ? ReturnType extends ResourceBase
                      ? Field[K] extends { fields: infer FieldSelection }
                        ? FieldSelection extends UnifiedFieldSelection<ReturnType>[]
                          ? InferResourceResult<ReturnType, FieldSelection>
                          : ReturnType
                        : ReturnType
                      : ReturnType
                    : any
                : K extends keyof Resource["relationships"]
                  ? // Relationship - use relationship schema for inference
                    Resource["relationships"][K] extends { __resource: infer R }
                      ? R extends ResourceBase
                        ? Resource["relationships"][K] extends { __array: true }
                          ? Array<InferResourceResult<R, Field[K]>>
                          : InferResourceResult<R, Field[K]>
                        : any
                      : any
                  : K extends keyof Resource["unions"]
                    ? // Union field selection - process union member selection
                      ProcessUnionFieldSelection<Resource["unions"][K], Field[K]>
                    : any
            }
          : any;

    // Main result type that processes each field using schema keys as classifiers
    type InferResourceResult<
      Resource extends ResourceBase,
      SelectedFields extends UnifiedFieldSelection<Resource>[]
    > = UnionToIntersection<
      {
        [K in keyof SelectedFields]: ProcessField<Resource, SelectedFields[K]>
      }[number]
    >;

    """
  end

  defp generate_helper_functions do
    """
    // Helper Functions
    
    /**
     * Gets the CSRF token from the page's meta tag
     * Returns null if no CSRF token is found
     */
    export function getPhoenixCSRFToken(): string | null {
      return document
        ?.querySelector("meta[name='csrf-token']")
        ?.getAttribute("content") || null;
    }

    /**
     * Builds headers object with CSRF token for Phoenix applications
     * Returns headers object with X-CSRF-Token (if available)
     */
    export function buildCSRFHeaders(): Record<string, string> {
      const headers: Record<string, string> = {};

      const csrfToken = getPhoenixCSRFToken();
      if (csrfToken) {
        headers["X-CSRF-Token"] = csrfToken;
      }

      return headers;
    }

    """
  end

  defp generate_rpc_functions(
         resources_and_actions,
         endpoint_process,
         endpoint_validate,
         otp_app,
         resources
       ) do
    # Generate relationship types for all resources
    relationship_types =
      resources
      |> Enum.map(&generate_relationship_types(&1, resources))
      |> Enum.join("\n\n")

    # Generate embedded types for all resources
    embedded_types =
      resources
      |> Enum.map(&generate_embedded_types(&1, resources))
      |> Enum.join("\n\n")

    # Generate functions for each Rpc action
    rpc_functions =
      resources_and_actions
      |> Enum.map(
        &generate_rpc_function(
          &1,
          resources_and_actions,
          endpoint_process,
          endpoint_validate,
          otp_app
        )
      )
      |> Enum.join("\n\n")

    """
    #{relationship_types}

    #{embedded_types}

    #{rpc_functions}
    """
  end

  defp generate_embedded_types(resource, all_resources) do
    resource_name = resource |> Module.split() |> List.last()

    # Check if any resource has this as a single embedded resource
    has_single_embedded? =
      all_resources
      |> Enum.reject(&(&1 == resource))
      |> Enum.any?(fn res ->
        attributes = Ash.Resource.Info.public_attributes(res)

        Enum.any?(attributes, fn attr ->
          AshTypescript.Codegen.is_embedded_resource?(attr.type) and attr.type == resource
        end)
      end)

    # Generate single embedded type
    single_embedded =
      if has_single_embedded? do
        """
          type #{resource_name}Embedded = {
            __resource: #{resource_name}ResourceSchema;
            fields: UnifiedFieldSelection<#{resource_name}ResourceSchema>[];
          };
        """
      else
        ""
      end

    # Check if any resource has this as an array embedded resource
    has_array_embedded? =
      all_resources
      |> Enum.reject(&(&1 == resource))
      |> Enum.any?(fn res ->
        attributes = Ash.Resource.Info.public_attributes(res)

        Enum.any?(attributes, fn attr ->
          case attr.type do
            {:array, embedded_type} ->
              AshTypescript.Codegen.is_embedded_resource?(embedded_type) and
                embedded_type == resource

            _ ->
              false
          end
        end)
      end)

    # Generate array embedded type
    array_embedded =
      if has_array_embedded? do
        """
        type #{resource_name}ArrayEmbedded = {
          __array: true;
          __resource: #{resource_name}ResourceSchema;
          fields: UnifiedFieldSelection<#{resource_name}ResourceSchema>[];
        };
        """
      else
        ""
      end

    if has_single_embedded? or has_array_embedded? do
      Enum.join([single_embedded, array_embedded], "\n")
    else
      ""
    end
  end

  defp generate_relationship_types(resource, all_resources) do
    resource_name = resource |> Module.split() |> List.last()

    has_single_relationship? =
      all_resources
      |> Enum.reject(&(&1 == resource))
      |> Enum.any?(fn res ->
        relationships = Ash.Resource.Info.public_relationships(res)

        Enum.any?(
          relationships,
          &(&1.type in [:belongs_to, :has_one] and &1.destination == resource)
        )
      end)

    # Generate single relationship type
    single_rel =
      if has_single_relationship? do
        """
          type #{resource_name}Relationship = {
            __resource: #{resource_name}ResourceSchema;
            fields: UnifiedFieldSelection<#{resource_name}ResourceSchema>[];
          };
        """
      else
        ""
      end

    has_many_relationship? =
      all_resources
      |> Enum.reject(&(&1 == resource))
      |> Enum.any?(fn res ->
        relationships = Ash.Resource.Info.public_relationships(res)

        Enum.any?(
          relationships,
          &(&1.type in [:has_many, :many_to_many] and &1.destination == resource)
        )
      end)

    # Generate array relationship type
    array_rel =
      if has_many_relationship? do
        """
        type #{resource_name}ArrayRelationship = {
          __array: true;
          __resource: #{resource_name}ResourceSchema;
          fields: UnifiedFieldSelection<#{resource_name}ResourceSchema>[];
        };
        """
      else
        ""
      end

    if has_single_relationship? or has_many_relationship? do
      Enum.join([single_rel, array_rel], "\n")
    else
      ""
    end
  end

  defp generate_rpc_function(
         {resource, action, rpc_action},
         _resources_and_actions,
         endpoint_process,
         endpoint_validate,
         _otp_app
       ) do
    # Convert Rpc action name to formatted function name using output_field_formatter
    rpc_action_name = to_string(rpc_action.name)

    # Generate config type
    config_type = generate_config_type(resource, action, rpc_action_name)

    # Generate result inference type
    result_type = generate_result_type(resource, action, rpc_action_name)

    # Generate payload builder
    payload_builder = generate_payload_builder(resource, rpc_action, action, rpc_action_name)

    # Generate Rpc function
    rpc_function =
      generate_rpc_execution_function(rpc_action, action, rpc_action_name, endpoint_process)

    # Generate validation function (for create, update, destroy actions only)
    validation_function =
      generate_validation_function(
        resource,
        rpc_action,
        action,
        rpc_action_name,
        endpoint_validate
      )

    functions_section =
      if validation_function == "" do
        rpc_function
      else
        """
        #{rpc_function}

        #{validation_function}
        """
      end

    """
    #{config_type}

    #{result_type}

    #{payload_builder}

    #{functions_section}
    """
  end

  defp generate_config_type(resource, action, rpc_action_name) do
    resource_name = resource |> Module.split() |> List.last()
    config_name = "#{snake_to_pascal_case(rpc_action_name)}Config"

    # Add tenant field if resource requires tenant
    tenant_field =
      if AshTypescript.Rpc.requires_tenant_parameter?(resource) do
        ["  tenant: string;"]
      else
        []
      end

    # Base config fields - use formatted field names
    formatted_fields_name =
      AshTypescript.FieldFormatter.format_field(
        "fields",
        AshTypescript.Rpc.output_field_formatter()
      )

    fields_field = [
      "  #{formatted_fields_name}: UnifiedFieldSelection<#{resource_name}ResourceSchema>[];"
    ]

    # Add headers field (optional)
    headers_field = [
      "  headers?: Record<string, string>;"
    ]

    # Add input fields based on action type
    input_fields =
      case action.type do
        :read ->
          filters =
            if action.get? do
              []
            else
              [
                "  filter?: #{resource_name}FilterInput;"
              ]
            end

          pagination_and_sort = [
            "  sort?: string;",
            "  page?: {",
            "    limit?: number;",
            "    offset?: number;",
            "  };"
          ]

          filters ++ pagination_and_sort

        :create ->
          accepts = Ash.Resource.Info.action(resource, action.name).accept || []
          arguments = action.arguments

          if accepts != [] || arguments != [] do
            ["  input: {"] ++
              Enum.map(accepts, fn field_name ->
                attr = Ash.Resource.Info.attribute(resource, field_name)
                optional = attr.allow_nil? || attr.default != nil
                base_type = AshTypescript.Codegen.get_ts_input_type(attr)
                field_type = if attr.allow_nil?, do: "#{base_type} | null", else: base_type

                formatted_field_name =
                  AshTypescript.FieldFormatter.format_field(
                    field_name,
                    AshTypescript.Rpc.output_field_formatter()
                  )

                "    #{formatted_field_name}#{if optional, do: "?", else: ""}: #{field_type};"
              end) ++
              Enum.map(arguments, fn arg ->
                optional = arg.allow_nil? || arg.default != nil

                formatted_arg_name =
                  AshTypescript.FieldFormatter.format_field(
                    arg.name,
                    AshTypescript.Rpc.output_field_formatter()
                  )

                "    #{formatted_arg_name}#{if optional, do: "?", else: ""}: #{get_ts_type(arg)};"
              end) ++
              ["  };"]
          else
            []
          end

        action_type when action_type in [:update, :destroy] ->
          primary_key_attrs = Ash.Resource.Info.primary_key(resource)

          primary_key_field =
            if Enum.count(primary_key_attrs) == 1 do
              attr_name = Enum.at(primary_key_attrs, 0)
              attr = Ash.Resource.Info.attribute(resource, attr_name)
              ["  primaryKey: #{get_ts_type(attr)};"]
            else
              ["  primaryKey: {"] ++
                Enum.map(primary_key_attrs, fn attr_name ->
                  attr = Ash.Resource.Info.attribute(resource, attr_name)
                  "    #{attr.name}: #{get_ts_type(attr)};"
                end) ++
                ["  };"]
            end

          input_fields =
            if action.accept != [] || action.arguments != [] do
              ["  input: {"] ++
                Enum.map(action.accept, fn field_name ->
                  attr = Ash.Resource.Info.attribute(resource, field_name)

                  formatted_field_name =
                    AshTypescript.FieldFormatter.format_field(
                      field_name,
                      AshTypescript.Rpc.output_field_formatter()
                    )

                  if attr.allow_nil? do
                    "    #{formatted_field_name}?: #{AshTypescript.Codegen.get_ts_input_type(attr)} | null;"
                  else
                    "    #{formatted_field_name}: #{AshTypescript.Codegen.get_ts_input_type(attr)};"
                  end
                end) ++
                Enum.map(action.arguments, fn arg ->
                  optional = arg.allow_nil? || arg.default != nil

                  formatted_arg_name =
                    AshTypescript.FieldFormatter.format_field(
                      arg.name,
                      AshTypescript.Rpc.output_field_formatter()
                    )

                  "    #{formatted_arg_name}#{if optional, do: "?", else: ""}: #{get_ts_type(arg)};"
                end) ++
                ["  };"]
            else
              []
            end

          primary_key_field ++ input_fields

        :action ->
          arguments = action.arguments

          if arguments != [] do
            ["  input: {"] ++
              Enum.map(arguments, fn arg ->
                optional = arg.allow_nil? || arg.default != nil

                formatted_arg_name =
                  AshTypescript.FieldFormatter.format_field(
                    arg.name,
                    AshTypescript.Rpc.output_field_formatter()
                  )

                "    #{formatted_arg_name}#{if optional, do: "?", else: ""}: #{get_ts_type(arg)};"
              end) ++
              ["  };"]
          else
            []
          end
      end

    all_fields =
      if action.type in [:read, :create, :update] do
        tenant_field ++ input_fields ++ fields_field ++ headers_field
      else
        tenant_field ++ input_fields ++ headers_field
      end

    """
    export type #{config_name} = {
    #{Enum.join(all_fields, "\n")}
    };
    """
  end

  defp generate_result_type(resource, action, rpc_action_name) do
    resource_name = resource |> Module.split() |> List.last()
    rpc_action_name_pascal = snake_to_pascal_case(rpc_action_name)

    case action.type do
      :read when action.get? ->
        """
        type Infer#{rpc_action_name_pascal}Result<Config extends #{rpc_action_name_pascal}Config> =
          InferResourceResult<#{resource_name}ResourceSchema, Config["fields"]> | null;
        """

      :read ->
        """
        type Infer#{rpc_action_name_pascal}Result<Config extends #{rpc_action_name_pascal}Config> =
          Array<InferResourceResult<#{resource_name}ResourceSchema, Config["fields"]>>;
        """

      action_type when action_type in [:create, :update] ->
        """
        type Infer#{rpc_action_name_pascal}Result<Config extends #{rpc_action_name_pascal}Config> =
          InferResourceResult<#{resource_name}ResourceSchema, Config["fields"]>;
        """

      :destroy ->
        """
        type Infer#{rpc_action_name_pascal}Result = void;
        """

      action_type when action_type in [:action, :generic] ->
        # For generic actions, use the returns type if specified
        if action.returns do
          return_type = get_ts_type(%{type: action.returns, constraints: action.constraints})

          """
          type Infer#{rpc_action_name_pascal}Result = #{return_type};
          """
        else
          """
          type Infer#{rpc_action_name_pascal}Result = any;
          """
        end
    end
  end

  defp generate_payload_builder(resource, _rpc_action, action, rpc_action_name) do
    rpc_action_name_pascal = snake_to_pascal_case(rpc_action_name)

    # Base payload construction with tenant handling
    formatted_fields_name =
      AshTypescript.FieldFormatter.format_field(
        "fields",
        AshTypescript.Rpc.output_field_formatter()
      )

    base_payload_with_tenant = fn ->
      if AshTypescript.Rpc.requires_tenant_parameter?(resource) do
        """
          const payload: Record<string, any> = {
            action: "#{rpc_action_name}",
            tenant: config.tenant,
            fields: config.#{formatted_fields_name}
          };
        """
      else
        """
          const payload: Record<string, any> = {
            action: "#{rpc_action_name}",
            fields: config.#{formatted_fields_name}
          };
        """
      end
    end

    cond do
      action.type == :read and not action.get? ->
        """
        export function build#{rpc_action_name_pascal}Payload(
          config: #{rpc_action_name_pascal}Config
        ): Record<string, any> {
        #{base_payload_with_tenant.()}

          if (config.filter) {
            payload.filter = config.filter;
          } else {
            payload.filter = {};
          }

          if (config.page) {
            payload.page = config.page;
          }

          if (config.sort) {
            payload.sort = config.sort;
          }

          if ("input" in config && config.input) {
            payload.input = config.input;
          } else {
            payload.input = {};
          }

          return payload;
        }
        """

      action.type == :read and action.get? ->
        """
        export function build#{rpc_action_name_pascal}Payload(
          config: #{rpc_action_name_pascal}Config
        ): Record<string, any> {
        #{base_payload_with_tenant.()}

          if ("input" in config && config.input) {
            payload.input = config.input;
          } else {
            payload.input = {};
          }

          return payload;
        }
        """

      action.type == :create ->
        """
        export function build#{rpc_action_name_pascal}Payload(
          config: #{rpc_action_name_pascal}Config
        ): Record<string, any> {
        #{base_payload_with_tenant.()}

          if ("input" in config && config.input) {
            payload.input = config.input;
          } else {
            payload.input = {};
          }

          return payload;
        }
        """

      action.type == :update ->
        update_payload_base =
          if AshTypescript.Rpc.requires_tenant_parameter?(resource) do
            """
            const payload: Record<string, any> = {
              action: "#{rpc_action_name}",
              tenant: config.tenant,
              fields: config.#{formatted_fields_name},
              primary_key: config.primaryKey
            };
            """
          else
            """
            const payload: Record<string, any> = {
              action: "#{rpc_action_name}",
              fields: config.#{formatted_fields_name},
              primary_key: config.primaryKey
            };
            """
          end

        """
        export function build#{rpc_action_name_pascal}Payload(
          config: #{rpc_action_name_pascal}Config
        ): Record<string, any> {
        #{update_payload_base}

          if ("input" in config && config.input) {
            payload.input = config.input;
          } else {
            payload.input = {};
          }

          return payload;
        }
        """

      action.type == :destroy ->
        destroy_payload_base =
          if AshTypescript.Rpc.requires_tenant_parameter?(resource) do
            """
            const payload: Record<string, any> = {
              action: "#{rpc_action_name}",
              tenant: config.tenant,
              primary_key: config.primaryKey
            };
            """
          else
            """
            const payload: Record<string, any> = {
              action: "#{rpc_action_name}",
              primary_key: config.primaryKey
            };
            """
          end

        """
        export function build#{rpc_action_name_pascal}Payload(
          config: #{rpc_action_name_pascal}Config
        ): Record<string, any> {
        #{destroy_payload_base}

          if ("input" in config && config.input) {
            payload.input = config.input;
          } else {
            payload.input = {};
          }

          return payload;
        }
        """

      action.type == :action ->
        action_payload_base =
          if AshTypescript.Rpc.requires_tenant_parameter?(resource) do
            """
            const payload: Record<string, any> = {
              action: "#{rpc_action_name}",
              tenant: config.tenant
            };
            """
          else
            """
            const payload: Record<string, any> = {
              action: "#{rpc_action_name}"
            };
            """
          end

        """
        export function build#{rpc_action_name_pascal}Payload(
          config: #{rpc_action_name_pascal}Config
        ): Record<string, any> {
        #{action_payload_base}

          if ("input" in config && config.input) {
            payload.input = config.input;
          } else {
            payload.input = {};
          }

          return payload;
        }
        """
    end
  end

  defp generate_rpc_execution_function(_rpc_action, action, rpc_action_name, endpoint_process) do
    function_name =
      AshTypescript.FieldFormatter.format_field(
        rpc_action_name,
        AshTypescript.Rpc.output_field_formatter()
      )

    # Add proper type handling for different action types
    is_generic_action = action.type in [:action, :generic]

    rpc_action_name_pascal = snake_to_pascal_case(rpc_action_name)

    result_handling =
      case action.type do
        :destroy ->
          "return;"

        _ when is_generic_action ->
          "return result.data as Infer#{rpc_action_name_pascal}Result;"

        _ ->
          "return result.data as Infer#{rpc_action_name_pascal}Result<#{rpc_action_name_pascal}Config>;"
      end

    result_type =
      case action.type do
        :destroy -> "void"
        _ when is_generic_action -> "Infer#{rpc_action_name_pascal}Result"
        _ -> "Infer#{rpc_action_name_pascal}Result<#{rpc_action_name_pascal}Config>"
      end

    """
    export async function #{function_name}(
      config: #{rpc_action_name_pascal}Config
    ): Promise<#{result_type}> {
      const payload = build#{rpc_action_name_pascal}Payload(config);

      const headers: Record<string, string> = {
        "Content-Type": "application/json",
        ...config.headers,
      };

      const response = await fetch("#{endpoint_process}", {
        method: "POST",
        headers,
        body: JSON.stringify(payload),
      });

      if (!response.ok) {
        throw new Error(`Rpc call failed: ${response.statusText}`);
      }

      const result = await response.json();
      #{result_handling}
    }
    """
  end

  defp generate_validation_function(
         resource,
         rpc_action,
         action,
         rpc_action_name,
         endpoint_validate
       ) do
    # Only generate validation functions for create, update, and destroy actions
    case action.type do
      :read ->
        ""

      :action ->
        ""

      _ ->
        # Convert Rpc action name using output formatter and add validate prefix
        validation_function_name =
          AshTypescript.FieldFormatter.format_field(
            "validate_" <> rpc_action_name,
            AshTypescript.Rpc.output_field_formatter()
          )

        primary_key_field_name =
          AshTypescript.FieldFormatter.format_field(
            "primary_key",
            AshTypescript.Rpc.output_field_formatter()
          )

        # Keep pascal case for config type references (TypeScript convention)
        rpc_action_name_pascal = AshTypescript.Helpers.snake_to_pascal_case(rpc_action_name)

        # Determine if we need primary_key parameter
        needs_primary_key = action.type in [:update, :destroy]

        # Check if action has input parameters
        has_input = length(action.accept) > 0 or length(action.arguments) > 0

        # Check if resource requires tenant
        requires_tenant = AshTypescript.Rpc.requires_tenant_parameter?(resource)

        # Build function signature including tenant parameter when needed
        base_params =
          case {needs_primary_key, has_input} do
            {true, true} ->
              [
                "#{primary_key_field_name}: string | number",
                "input: #{rpc_action_name_pascal}Config[\"input\"]"
              ]

            {true, false} ->
              ["#{primary_key_field_name}: string | number"]

            {false, true} ->
              ["input: #{rpc_action_name_pascal}Config[\"input\"]"]

            {false, false} ->
              []
          end

        all_params =
          if requires_tenant do
            ["tenant: string"] ++ base_params
          else
            base_params
          end

        params = Enum.join(all_params, ", ")

        # Build payload construction
        base_payload =
          if requires_tenant do
            ["action: \"#{rpc_action.name}\"", "tenant: tenant"]
          else
            ["action: \"#{rpc_action.name}\""]
          end

        payload_with_pk =
          if needs_primary_key do
            base_payload ++ ["primary_key: #{primary_key_field_name}"]
          else
            base_payload
          end

        payload_lines =
          if has_input do
            payload_with_pk ++ ["input: input"]
          else
            payload_with_pk ++ ["input: {}"]
          end

        payload_content = Enum.join(payload_lines, ",\n    ")

        """
        export async function #{validation_function_name}(#{params}, headers?: Record<string, string>): Promise<{
          success: boolean;
          errors?: Record<string, string[]>;
        }> {
          const payload = {
            #{payload_content}
          };

          const requestHeaders: Record<string, string> = {
            "Content-Type": "application/json",
            ...headers,
          };

          const response = await fetch("#{endpoint_validate}", {
            method: "POST",
            headers: requestHeaders,
            body: JSON.stringify(payload),
          });

          if (!response.ok) {
            throw new Error(`Validation call failed: ${response.statusText}`);
          }

          const result = await response.json();

          if (result.success) {
            return { success: true };
          } else {
            return { success: false, errors: result.errors };
          }
        }
        """
    end
  end
end

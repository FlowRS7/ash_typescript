defmodule AshTypescript.RPC.Codegen do
  @moduledoc """
  Generates TypeScript code for interacting with Ash resources via RPC.
  """

  def generate_typescript_types(otp_app, rpc_specs, opts \\ []) do
    endpoint_process = Keyword.get(opts, :process_endpoint, "/rpc/run")
    endpoint_validate = Keyword.get(opts, :validate_endpoint, "/rpc/validate")

    resources_and_actions = get_resources_and_actions(otp_app)

    # Collect all resources from all domains
    resources =
      otp_app
      |> Ash.Info.domains()
      |> Enum.flat_map(&Ash.Domain.Info.resources/1)
      |> Enum.uniq()

    generate_full_typescript(
      resources,
      rpc_specs,
      resources_and_actions,
      endpoint_process,
      endpoint_validate,
      otp_app
    )
  end

  defp get_resources_and_actions(otp_app) do
    otp_app
    |> Ash.Info.domains()
    |> Enum.flat_map(fn domain ->
      # Get RPC configuration from the domain
      rpc_config = AshTypescript.RPC.Info.rpc(domain)

      Enum.flat_map(rpc_config, fn %{resource: resource, rpc_actions: rpc_actions} ->
        Enum.map(rpc_actions, fn rpc_action ->
          action = Ash.Resource.Info.action(resource, rpc_action.action)
          {resource, action, rpc_action}
        end)
      end)
    end)
  end

  defp generate_full_typescript(
         resources,
         rpc_specs,
         resources_and_actions,
         endpoint_process,
         endpoint_validate,
         otp_app
       ) do
    """
    // Generated by AshTypescript
    // Do not edit this file manually

    #{generate_imports()}

    #{generate_resource_schemas(resources, otp_app)}

    #{generate_utility_types()}

    #{generate_helper_functions()}

    #{generate_rpc_functions(rpc_specs, resources_and_actions, endpoint_process, endpoint_validate, otp_app, resources)}
    """
  end

  defp generate_imports do
    """
    // Base types
    type UUID = string;
    type DateTime = string;
    type AshDate = string;
    type JsonValue = string | number | boolean | null | JsonValue[] | { [key: string]: JsonValue };
    """
  end

  defp generate_resource_schemas(resources, otp_app) do
    resources
    |> Enum.map(&generate_resource_schema(&1, otp_app))
    |> Enum.join("\n\n")
  end

  defp generate_resource_schema(resource, otp_app) do
    resource_name = resource |> Module.split() |> List.last()

    select_schema = generate_select_schema(resource)
    calculated_fields_schema = generate_calculated_fields_schema(resource)
    aggregate_fields_schema = generate_aggregate_fields_schema(resource)
    relationship_schema = generate_relationship_schema(resource, otp_app)

    """
    // #{resource_name} Schemas
    #{select_schema}

    #{calculated_fields_schema}

    #{aggregate_fields_schema}

    #{relationship_schema}
    """
  end

  defp generate_select_schema(resource) do
    resource_name = resource |> Module.split() |> List.last()

    attributes =
      resource
      |> Ash.Resource.Info.attributes()
      |> Enum.filter(fn attr ->
        attr.public? || attr.name in [:created_at, :updated_at, :inserted_at]
      end)
      |> Enum.map(fn attr ->
        "  #{attr.name}: #{attribute_to_typescript_type(attr)};"
      end)
      |> Enum.join("\n")

    """
    type #{resource_name}SelectSchema = {
    #{attributes}
    };
    """
  end

  defp generate_calculated_fields_schema(resource) do
    resource_name = resource |> Module.split() |> List.last()

    calculations =
      resource
      |> Ash.Resource.Info.calculations()
      |> Enum.filter(& &1.public?)
      |> Enum.map(fn calc ->
        "  #{calc.name}: #{ash_type_to_typescript(calc.type)};"
      end)

    if Enum.empty?(calculations) do
      "type #{resource_name}CalculatedFieldsSchema = {};"
    else
      """
      type #{resource_name}CalculatedFieldsSchema = {
      #{Enum.join(calculations, "\n")}
      };
      """
    end
  end

  defp generate_aggregate_fields_schema(resource) do
    resource_name = resource |> Module.split() |> List.last()

    aggregates =
      resource
      |> Ash.Resource.Info.aggregates()
      |> Enum.map(fn agg ->
        type =
          case agg.kind do
            :count -> "number"
            :exists -> "boolean"
            :sum -> "number"
            :avg -> "number"
            :max -> ash_type_to_typescript(agg.type || :integer)
            :min -> ash_type_to_typescript(agg.type || :integer)
            :first -> ash_type_to_typescript(agg.type || :string)
            :list -> "Array<#{ash_type_to_typescript(agg.type || :string)}>"
            _ -> "any"
          end

        "  #{agg.name}: #{type};"
      end)

    if Enum.empty?(aggregates) do
      "type #{resource_name}AggregateFieldsSchema = {};"
    else
      """
      type #{resource_name}AggregateFieldsSchema = {
      #{Enum.join(aggregates, "\n")}
      };
      """
    end
  end

  defp generate_relationship_schema(resource, _otp_app) do
    resource_name = resource |> Module.split() |> List.last()

    relationships =
      resource
      |> Ash.Resource.Info.relationships()
      |> Enum.map(fn rel ->
        related_resource_name = rel.destination |> Module.split() |> List.last()

        case rel.type do
          :belongs_to ->
            "  #{rel.name}: #{related_resource_name}Relationship;"

          :has_one ->
            "  #{rel.name}: #{related_resource_name}Relationship;"

          :has_many ->
            "  #{rel.name}: #{pluralize_resource_name(related_resource_name)}ArrayRelationship;"

          :many_to_many ->
            "  #{rel.name}: #{pluralize_resource_name(related_resource_name)}ArrayRelationship;"
        end
      end)

    if Enum.empty?(relationships) do
      "type #{resource_name}RelationshipSchema = {};"
    else
      """
      type #{resource_name}RelationshipSchema = {
      #{Enum.join(relationships, "\n")}
      };
      """
    end
  end

  defp generate_utility_types do
    """
    // Utility Types
    type PickFields<T, K extends keyof T> = Pick<T, K>;

    type ExtractCalculatedFields<
      T extends Record<string, any>,
      CalcFields extends Record<string, any>
    > = {
      [K in keyof T & keyof CalcFields]: CalcFields[K];
    };

    type CalculatedFieldsResult<T, CalcFields> = T extends Record<string, any>
      ? ExtractCalculatedFields<T, CalcFields>
      : {};

    type InferResourceResult<
      Resource extends Record<string, any>,
      Config extends {
        fields?: (keyof Resource)[];
        calculatedFields?: Record<string, any>;
        aggregateFields?: Record<string, any>;
        load?: Record<string, any>;
      }
    > = (Config["fields"] extends (keyof Resource)[]
      ? PickFields<Resource, Config["fields"][number]>
      : Resource) &
      (Config["calculatedFields"] extends Record<string, any>
        ? CalculatedFieldsResult<Config["calculatedFields"], any>
        : {}) &
      (Config["aggregateFields"] extends Record<string, any>
        ? Config["aggregateFields"]
        : {}) &
      (Config["load"] extends Record<string, any>
        ? InferRelationshipsFromMap<Config["load"]>
        : {});

    type InferRelationshipsFromMap<LoadMap> = {
      [K in keyof LoadMap]: LoadMap[K] extends {
        fields?: any[];
        calculatedFields?: Record<string, any>;
        aggregateFields?: Record<string, any>;
        load?: Record<string, any>;
      }
        ? LoadMap[K] extends { __array: true }
          ? Array<
              InferResourceResult<
                any,
                {
                  fields: LoadMap[K]["fields"];
                  calculatedFields: LoadMap[K]["calculatedFields"];
                  aggregateFields: LoadMap[K]["aggregateFields"];
                  load: LoadMap[K]["load"];
                }
              >
            >
          : InferResourceResult<
              any,
              {
                fields: LoadMap[K]["fields"];
                calculatedFields: LoadMap[K]["calculatedFields"];
                aggregateFields: LoadMap[K]["aggregateFields"];
                load: LoadMap[K]["load"];
              }
            >
        : never;
    };

    type InferArrayRelationshipResult<
      RelationshipType,
      Config extends {
        fields?: any[];
        calculatedFields?: Record<string, any>;
        aggregateFields?: Record<string, any>;
        load?: Record<string, any>;
      }
    > = RelationshipType extends { __array: true; __resource: infer Resource }
      ? Array<
          InferResourceResult<
            Resource,
            {
              fields: Config["fields"];
              calculatedFields: Config["calculatedFields"];
              aggregateFields: Config["aggregateFields"];
              load: Config["load"];
            }
          >
        >
      : never;

    type CalculatedFieldsConfig<T> = {
      [K in keyof T]?: boolean;
    };

    type AggregateFieldsConfig<T> = {
      [K in keyof T]?: boolean;
    };

    type LoadConfig<T> = {
      [K in keyof T]?: T[K] extends { __array: true }
        ? ArrayRelationshipConfig<T[K]>
        : RelationshipConfig<T[K]>;
    };

    type RelationshipConfig<T> = T extends {
      __resource: infer Resource;
      fields?: any;
      calculatedFields?: any;
      aggregateFields?: any;
      load?: any;
    }
      ? {
          fields?: T["fields"];
          calculatedFields?: T["calculatedFields"];
          aggregateFields?: T["aggregateFields"];
          load?: T["load"];
        }
      : never;

    type ArrayRelationshipConfig<T> = T extends {
      __array: true;
      __resource: infer Resource;
      fields?: any;
      calculatedFields?: any;
      aggregateFields?: any;
      load?: any;
    }
      ? {
          fields?: T["fields"];
          calculatedFields?: T["calculatedFields"];
          aggregateFields?: T["aggregateFields"];
          load?: T["load"];
        }
      : never;
    """
  end

  defp generate_rpc_functions(
         rpc_specs,
         resources_and_actions,
         endpoint_process,
         endpoint_validate,
         otp_app,
         all_resources
       ) do
    # Generate relationship types for all resources
    relationship_types =
      all_resources
      |> Enum.map(&generate_relationship_types(&1, otp_app))
      |> Enum.join("\n\n")

    # Generate functions for each RPC spec
    rpc_functions =
      rpc_specs
      |> Enum.map(
        &generate_rpc_function(
          &1,
          resources_and_actions,
          endpoint_process,
          endpoint_validate,
          otp_app
        )
      )
      |> Enum.join("\n\n")

    """
    #{relationship_types}

    #{rpc_functions}
    """
  end

  defp generate_relationship_types(resource, _otp_app) do
    resource_name = resource |> Module.split() |> List.last()

    # Generate single relationship type
    single_rel = """
    type #{resource_name}Relationship = {
      __resource: #{resource_name}SelectSchema;
      fields?: (keyof #{resource_name}SelectSchema)[];
      calculatedFields?: CalculatedFieldsConfig<#{resource_name}CalculatedFieldsSchema>;
      aggregateFields?: AggregateFieldsConfig<#{resource_name}AggregateFieldsSchema>;
      load?: LoadConfig<#{resource_name}RelationshipSchema>;
    };
    """

    # Generate array relationship type
    array_rel = """
    type #{pluralize_resource_name(resource_name)}ArrayRelationship = {
      __array: true;
      __resource: #{resource_name}SelectSchema;
      fields?: (keyof #{resource_name}SelectSchema)[];
      calculatedFields?: CalculatedFieldsConfig<#{resource_name}CalculatedFieldsSchema>;
      aggregateFields?: AggregateFieldsConfig<#{resource_name}AggregateFieldsSchema>;
      load?: LoadConfig<#{resource_name}RelationshipSchema>;
    };
    """

    """
    #{single_rel}

    #{array_rel}
    """
  end

  defp generate_rpc_function(
         rpc_spec,
         resources_and_actions,
         endpoint_process,
         _endpoint_validate,
         _otp_app
       ) do
    {resource, action, rpc_action} = find_resource_and_action(rpc_spec, resources_and_actions)
    _resource_name = resource |> Module.split() |> List.last()
    _action_name = rpc_spec["action"]
    # Convert RPC action name to camelCase function name (e.g., read_todo -> readTodos)
    rpc_action_name = to_string(rpc_action.name)

    # Generate config type
    config_type = generate_config_type(resource, action, rpc_action_name)

    # Generate result inference type
    result_type = generate_result_type(resource, action, rpc_action_name)

    # Generate payload builder
    payload_builder = generate_payload_builder(rpc_spec, action, rpc_action_name)

    # Generate RPC function
    rpc_function =
      generate_rpc_execution_function(rpc_spec, action, rpc_action_name, endpoint_process)

    """
    #{config_type}

    #{result_type}

    #{payload_builder}

    #{rpc_function}
    """
  end

  defp generate_config_type(resource, action, rpc_action_name) do
    resource_name = resource |> Module.split() |> List.last()
    function_name = to_camel_case(rpc_action_name)
    config_name = "#{capitalize_first(function_name)}Config"

    # Base config fields
    base_fields = [
      "  fields?: (keyof #{resource_name}SelectSchema)[];",
      "  calculatedFields?: CalculatedFieldsConfig<#{resource_name}CalculatedFieldsSchema>;",
      "  aggregateFields?: AggregateFieldsConfig<#{resource_name}AggregateFieldsSchema>;",
      "  load?: LoadConfig<#{resource_name}RelationshipSchema>;"
    ]

    # Add input fields based on action type
    input_fields =
      case action.type do
        :read ->
          filters =
            if action.arguments != [] do
              ["  filters?: {"] ++
                Enum.map(action.arguments, fn arg ->
                  "    #{arg.name}?: #{ash_type_to_typescript(arg.type)};"
                end) ++
                ["  };"]
            else
              []
            end

          pagination = [
            "  pagination?: {",
            "    limit?: number;",
            "    offset?: number;",
            "  };"
          ]

          filters ++ pagination

        :create ->
          accepts = Ash.Resource.Info.action(resource, action.name).accept || []
          arguments = action.arguments

          input_fields =
            if accepts != [] || arguments != [] do
              ["  input: {"] ++
                Enum.map(accepts, fn field_name ->
                  attr = Ash.Resource.Info.attribute(resource, field_name)
                  optional = attr.allow_nil? || attr.default != nil
                  base_type = ash_type_to_typescript(attr.type)
                  field_type = if attr.allow_nil?, do: "#{base_type} | null", else: base_type

                  "    #{field_name}#{if optional, do: "?", else: ""}: #{field_type};"
                end) ++
                Enum.map(arguments, fn arg ->
                  optional = arg.allow_nil? || arg.default != nil

                  "    #{arg.name}#{if optional, do: "?", else: ""}: #{ash_type_to_typescript(arg.type)};"
                end) ++
                ["  };"]
            else
              []
            end

          input_fields

        :update ->
          accepts = Ash.Resource.Info.action(resource, action.name).accept || []
          arguments = action.arguments

          id_field = ["  id: UUID;"]

          input_fields =
            if accepts != [] || arguments != [] do
              ["  input: {"] ++
                Enum.map(accepts, fn field_name ->
                  attr = Ash.Resource.Info.attribute(resource, field_name)
                  "    #{field_name}?: #{attribute_to_typescript_type(attr)};"
                end) ++
                Enum.map(arguments, fn arg ->
                  optional = arg.allow_nil? || arg.default != nil

                  "    #{arg.name}#{if optional, do: "?", else: ""}: #{ash_type_to_typescript(arg.type)};"
                end) ++
                ["  };"]
            else
              []
            end

          id_field ++ input_fields

        :destroy ->
          ["  id: UUID;"]

        action_type when action_type in [:action, :generic] ->
          arguments = action.arguments

          if arguments != [] do
            ["  input: {"] ++
              Enum.map(arguments, fn arg ->
                optional = arg.allow_nil? || arg.default != nil

                "    #{arg.name}#{if optional, do: "?", else: ""}: #{ash_type_to_typescript(arg.type)};"
              end) ++
              ["  };"]
          else
            []
          end
      end

    all_fields = input_fields ++ base_fields

    """
    type #{config_name} = {
    #{Enum.join(all_fields, "\n")}
    };
    """
  end

  defp generate_result_type(resource, action, rpc_action_name) do
    resource_name = resource |> Module.split() |> List.last()
    function_name = to_camel_case(rpc_action_name)

    case action.type do
      :read when action.get? ->
        """
        type Infer#{capitalize_first(function_name)}Result<Config extends #{capitalize_first(function_name)}Config> =
          InferResourceResult<#{resource_name}SelectSchema, Config> | null;
        """

      :read ->
        """
        type Infer#{capitalize_first(function_name)}Result<Config extends #{capitalize_first(function_name)}Config> =
          Array<InferResourceResult<#{resource_name}SelectSchema, Config>>;
        """

      action_type when action_type in [:create, :update] ->
        """
        type Infer#{capitalize_first(function_name)}Result<Config extends #{capitalize_first(function_name)}Config> =
          InferResourceResult<#{resource_name}SelectSchema, Config>;
        """

      :destroy ->
        """
        type Infer#{capitalize_first(function_name)}Result = void;
        """

      action_type when action_type in [:action, :generic] ->
        # For generic actions, use the returns type if specified
        if action.returns do
          return_type =
            case action.returns do
              {:array, Ash.Type.Struct} ->
                # For struct arrays, assume they return instances of the same resource
                resource_name = resource |> Module.split() |> List.last()
                "Array<#{resource_name}SelectSchema>"

              _ ->
                ash_type_to_typescript(action.returns)
            end

          """
          type Infer#{capitalize_first(function_name)}Result = #{return_type};
          """
        else
          """
          type Infer#{capitalize_first(function_name)}Result = any;
          """
        end
    end
  end

  defp generate_payload_builder(_rpc_spec, action, rpc_action_name) do
    function_name = to_camel_case(rpc_action_name)

    """
    function build#{capitalize_first(function_name)}Payload(
      config: #{capitalize_first(function_name)}Config
    ): Record<string, any> {
      const payload: Record<string, any> = {
        action: "#{action.name}"
      };

      // Add select fields
      if (config.fields) {
        payload.select = config.fields;
      } else {
        payload.select = [];
      }

      // Build load array from load configuration
      if (config.load) {
        payload.load = buildLoadArray(config.load);
      } else {
        payload.load = [];
      }

      // Handle input based on action type
      #{generate_payload_input_handling(action)}

      return payload;
    }
    """
  end

  defp generate_rpc_execution_function(_rpc_spec, action, rpc_action_name, endpoint_process) do
    function_name = to_camel_case(rpc_action_name)

    # Add proper type handling for different action types
    is_generic_action = action.type in [:action, :generic]

    result_handling =
      case action.type do
        :destroy ->
          "return;"

        _ when is_generic_action ->
          "return result.data as Infer#{capitalize_first(function_name)}Result;"

        _ ->
          "return result.data as Infer#{capitalize_first(function_name)}Result<Config>;"
      end

    {config_type_param, config_param} =
      case action.type do
        :destroy -> {"", "config: #{capitalize_first(function_name)}Config"}
        _ when is_generic_action -> {"", "config: #{capitalize_first(function_name)}Config"}
        _ -> {"<Config extends #{capitalize_first(function_name)}Config>", "config: Config"}
      end

    result_type =
      case action.type do
        :destroy -> "void"
        _ when is_generic_action -> "Infer#{capitalize_first(function_name)}Result"
        _ -> "Infer#{capitalize_first(function_name)}Result<Config>"
      end

    """
    async function #{function_name}#{config_type_param}(
      #{config_param}
    ): Promise<#{result_type}> {
      const payload = build#{capitalize_first(function_name)}Payload(config);

      const response = await fetch("#{endpoint_process}", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(payload),
      });

      if (!response.ok) {
        throw new Error(`RPC call failed: ${response.statusText}`);
      }

      const result = await response.json();
      #{result_handling}
    }
    """
  end

  defp find_resource_and_action(rpc_spec, resources_and_actions) do
    # The RPC spec "action" field contains the RPC action name (e.g., "read_todo")
    rpc_action_name = rpc_spec["action"]

    case Enum.find(resources_and_actions, fn {_resource, _action, rpc_action} ->
           to_string(rpc_action.name) == rpc_action_name
         end) do
      {resource, action, rpc_action} -> {resource, action, rpc_action}
      nil -> raise "Could not find RPC action #{rpc_action_name}"
    end
  end

  defp generate_payload_input_handling(action) do
    case action.type do
      :read ->
        """
        if ("filters" in config && config.filters) {
          const filter: Record<string, any> = {};

          for (const [key, value] of Object.entries(config.filters)) {
            if (value !== undefined) {
              filter[key] = value;
            }
          }

          if (Object.keys(filter).length > 0) {
            payload.filter = filter;
          }
        }

        if ("pagination" in config && config.pagination) {
          if (config.pagination.limit !== undefined) {
            payload.limit = config.pagination.limit;
          }
          if (config.pagination.offset !== undefined) {
            payload.offset = config.pagination.offset;
          }
        }

        payload.input = {};
        """

      :create ->
        """
        if ("input" in config) {
          payload.input = config.input;
        } else {
          payload.input = {};
        }
        """

      :update ->
        """
        const updateConfig = config as { id: any; input: any };
        payload.input = { ...updateConfig.input, id: updateConfig.id };
        """

      :destroy ->
        """
        const destroyConfig = config as { id: any };
        payload.input = { id: destroyConfig.id };
        """

      action_type when action_type in [:action, :generic] ->
        """
        if ("input" in config) {
          payload.input = config.input;
        } else {
          payload.input = {};
        }
        """

      _ ->
        """
        payload.input = {};
        """
    end
  end

  defp attribute_to_typescript_type(attribute) do
    base_type = ash_type_to_typescript(attribute.type)

    if attribute.allow_nil? do
      "#{base_type} | null"
    else
      base_type
    end
  end

  defp ash_type_to_typescript(type) do
    case type do
      :string ->
        "string"

      :ci_string ->
        "string"

      :integer ->
        "number"

      :float ->
        "number"

      :decimal ->
        "number"

      :boolean ->
        "boolean"

      :date ->
        "AshDate"

      :time ->
        "string"

      :datetime ->
        "DateTime"

      :utc_datetime ->
        "DateTime"

      :utc_datetime_usec ->
        "DateTime"

      Ash.Type.UtcDatetimeUsec ->
        "DateTime"

      :naive_datetime ->
        "DateTime"

      :uuid ->
        "UUID"

      :atom ->
        "string"

      :map ->
        "Record<string, any>"

      :keyword_list ->
        "Record<string, any>"

      :term ->
        "any"

      {:array, inner_type} ->
        "Array<#{ash_type_to_typescript(inner_type)}>"

      Ash.Type.Term ->
        "any"

      Ash.Type.String ->
        "string"

      Ash.Type.Integer ->
        "number"

      Ash.Type.Boolean ->
        "boolean"

      Ash.Type.Map ->
        "Record<string, any>"

      Ash.Type.Atom ->
        "string"

      Ash.Type.Date ->
        "AshDate"

      Ash.Type.Struct ->
        "Record<string, any>"

      Ash.Type.UtcDatetime ->
        "DateTime"

      Ash.Type.DateTime ->
        "DateTime"

      module when is_atom(module) ->
        # Check if it's an Ash.Type.Enum
        try do
          # First ensure the module is loaded
          Code.ensure_loaded!(module)

          # Check if it has the Ash.Type behaviour and values/0 function
          if function_exported?(module, :values, 0) &&
               function_exported?(module, :cast_input, 2) do
            values = apply(module, :values, [])

            if is_list(values) && Enum.all?(values, &is_atom/1) do
              values
              |> Enum.map(&"\"#{&1}\"")
              |> Enum.join(" | ")
            else
              # Not a proper enum, fallback to module name
              module |> Module.split() |> List.last()
            end
          else
            # For custom types, try to get a simple name
            module |> Module.split() |> List.last()
          end
        rescue
          _ ->
            # If anything fails, fallback to module name
            module |> Module.split() |> List.last()
        end

      _ ->
        "any"
    end
  end

  defp to_camel_case(string) do
    # Convert snake_case RPC action names to camelCase function names
    # e.g., "read_todo" -> "readTodos", "get_todo" -> "getTodo"
    parts = String.split(string, "_")

    case parts do
      [action | rest] ->
        resource_name = rest |> Enum.map(&capitalize_first/1) |> Enum.join("")

        # Pluralize for read actions that return lists
        if action == "read" && resource_name != "" do
          action <> pluralize_resource_name(resource_name)
        else
          action <> resource_name
        end

      _ ->
        string
    end
  end

  defp capitalize_first(string) do
    case String.split_at(string, 1) do
      {"", _} -> string
      {first, rest} -> String.upcase(first) <> rest
    end
  end

  defp generate_helper_functions do
    """
    // Helper function to build load arrays from load configuration
    function buildLoadArray(loadConfig: any): any[] {
      const result: any[] = [];

      for (const [key, value] of Object.entries(loadConfig)) {
        if (value && typeof value === 'object') {
          const loadItem: any = { [key]: [] };

          if ('fields' in value && value.fields) {
            loadItem[key] = value.fields;
          }

          if ('load' in value && value.load) {
            const nestedLoad = buildLoadArray(value.load);
            if (nestedLoad.length > 0) {
              loadItem[key] = [...(loadItem[key] || []), ...nestedLoad];
            }
          }

          result.push(loadItem);
        } else if (value === true) {
          result.push(key);
        }
      }

      return result;
    }
    """
  end

  defp pluralize_resource_name(name) do
    # Simple pluralization rules
    cond do
      String.ends_with?(name, "y") && !String.match?(name, ~r/[aeiou]y$/) ->
        String.slice(name, 0..-2//1) <> "ies"

      String.ends_with?(name, "s") || String.ends_with?(name, "x") ||
        String.ends_with?(name, "z") || String.ends_with?(name, "ch") ||
          String.ends_with?(name, "sh") ->
        name <> "es"

      true ->
        name <> "s"
    end
  end
end

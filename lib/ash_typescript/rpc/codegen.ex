defmodule AshTypescript.Rpc.Codegen do
  @moduledoc """
  Generates TypeScript code for interacting with Ash resources via Rpc.
  """
  import AshTypescript.Codegen
  import AshTypescript.Filter
  import AshTypescript.Helpers

  alias AshTypescript.Rpc.RequestedFieldsProcessor

  def generate_typescript_types(otp_app, opts \\ []) do
    endpoint_process = Keyword.get(opts, :run_endpoint, "/rpc/run")
    endpoint_validate = Keyword.get(opts, :validate_endpoint, "/rpc/validate")

    resources_and_actions = get_rpc_resources_and_actions(otp_app)

    generate_full_typescript(
      resources_and_actions,
      endpoint_process,
      endpoint_validate,
      otp_app
    )
  end

  defp get_rpc_resources_and_actions(otp_app) do
    otp_app
    |> Ash.Info.domains()
    |> Enum.flat_map(fn domain ->
      # Get Rpc configuration from the domain
      rpc_config = AshTypescript.Rpc.Info.rpc(domain)

      Enum.flat_map(rpc_config, fn %{resource: resource, rpc_actions: rpc_actions} ->
        Enum.map(rpc_actions, fn rpc_action ->
          action = Ash.Resource.Info.action(resource, rpc_action.action)
          {resource, action, rpc_action}
        end)
      end)
    end)
  end

  defp get_typed_queries(otp_app) do
    otp_app
    |> Ash.Info.domains()
    |> Enum.flat_map(fn domain ->
      # Get Rpc configuration from the domain
      rpc_config = AshTypescript.Rpc.Info.rpc(domain)

      Enum.flat_map(rpc_config, fn %{resource: resource, typed_queries: typed_queries} ->
        Enum.map(typed_queries, fn typed_query ->
          action = Ash.Resource.Info.action(resource, typed_query.action)
          {resource, action, typed_query}
        end)
      end)
    end)
  end

  defp generate_imports() do
    case Application.get_env(:ash_typescript, :import_into_generated) do
      nil ->
        ""

      imports when is_list(imports) ->
        imports
        |> Enum.map(fn import_config ->
          import_name = Map.get(import_config, :import_name)
          file_path = Map.get(import_config, :file)

          if import_name && file_path do
            "import * as #{import_name} from \"#{file_path}\";"
          else
            ""
          end
        end)
        |> Enum.reject(&(&1 == ""))
        |> Enum.join("\n")
        |> case do
          "" -> ""
          imports_str -> imports_str <> "\n"
        end

      _ ->
        ""
    end
  end

  defp generate_full_typescript(
         rpc_resources_and_actions,
         endpoint_process,
         endpoint_validate,
         otp_app
       ) do
    # Extract only the Rpc resources
    rpc_resources =
      otp_app
      |> Ash.Info.domains()
      |> Enum.flat_map(fn domain ->
        AshTypescript.Rpc.Info.rpc(domain)
        |> Enum.map(fn %{resource: r} -> r end)
      end)

    actions =
      otp_app
      |> Ash.Info.domains()
      |> Enum.flat_map(fn domain ->
        AshTypescript.Rpc.Info.rpc(domain)
        |> Enum.flat_map(fn %{resource: resource, rpc_actions: rpc_actions} ->
          Enum.map(rpc_actions, fn %{action: action} ->
            Ash.Resource.Info.action(resource, action)
          end)
        end)
      end)

    # Get typed queries
    typed_queries = get_typed_queries(otp_app)

    # Discover embedded resources and include them in schema generation
    embedded_resources = AshTypescript.Codegen.find_embedded_resources(rpc_resources)
    all_resources_for_schemas = rpc_resources ++ embedded_resources

    """
    // Generated by AshTypescript
    // Do not edit this file manually

    #{generate_imports()}

    #{generate_ash_type_aliases(rpc_resources, actions)}

    #{generate_all_schemas_for_resources(all_resources_for_schemas, all_resources_for_schemas)}

    #{generate_typed_structs_schemas(all_resources_for_schemas)}

    #{generate_filter_types(all_resources_for_schemas, all_resources_for_schemas)}

    #{generate_utility_types()}

    #{generate_helper_functions()}

    #{generate_typed_queries_section(typed_queries, all_resources_for_schemas)}

    #{generate_rpc_functions(rpc_resources_and_actions, endpoint_process, endpoint_validate, otp_app, all_resources_for_schemas)}
    """
  end

  defp generate_utility_types do
    """
    // Utility Types
    
    // Resource schema constraint
    type TypedSchema = {
      __type: "Resource" | "TypedStruct" | "TypedMap" | "Union";
      __primitiveFields: string;
    };

    // Utility type to convert union to intersection
    type UnionToIntersection<U> = (U extends any ? (k: U) => void : never) extends (
      k: infer I,
    ) => void
      ? I
      : never;

    type HasComplexFields<T extends TypedSchema> = keyof Omit<
      T,
      "__primitiveFields" | "__type" | T["__primitiveFields"]
    > extends never
      ? false
      : true;

    type ComplexFieldKeys<T extends TypedSchema> = keyof Omit<
      T,
      "__primitiveFields" | "__type" | T["__primitiveFields"]
    >;

    type LeafFieldSelection<T extends TypedSchema> = T["__primitiveFields"];

    type ComplexFieldSelection<T extends TypedSchema> = {
      [K in ComplexFieldKeys<T>]?: NonNullable<T[K]> extends {
        __type: "Relationship";
        __resource: infer Resource extends TypedSchema;
      }
        ? UnifiedFieldSelection<Resource>[]
        : T[K] extends {
              __type: "ComplexCalculation";
              __returnType: infer ReturnType;
            }
          ? T[K] extends { __args: infer Args }
            ? NonNullable<ReturnType> extends TypedSchema
              ? {
                  args: Args;
                  fields: UnifiedFieldSelection<NonNullable<ReturnType>>[];
                }
              : { args: Args }
            : NonNullable<ReturnType> extends TypedSchema
              ? { fields: UnifiedFieldSelection<NonNullable<ReturnType>>[] }
              : never
          : NonNullable<T[K]> extends TypedSchema
            ? UnifiedFieldSelection<NonNullable<T[K]>>[]
            : never;
    };

    // Main type: Use explicit base case detection to prevent infinite recursion
    type UnifiedFieldSelection<T extends TypedSchema> =
      HasComplexFields<T> extends false
        ? LeafFieldSelection<T> // Base case: only primitives, no recursion
        : LeafFieldSelection<T> | ComplexFieldSelection<T>; // Recursive case

    type InferFieldValue<
      T extends TypedSchema,
      Field,
    > = Field extends T["__primitiveFields"]
      ? Field extends keyof T
        ? { [K in Field]: T[Field] }
        : never
      : Field extends Record<string, any>
        ? {
            [K in keyof Field]: K extends keyof T
              ? T[K] extends {
                  __type: "Relationship";
                  __resource: infer Resource extends TypedSchema;
                }
                ? T[K] extends { __array: true }
                  ? Array<InferResult<Resource, Field[K]>>
                  : null extends Resource
                    ? InferResult<Resource, Field[K]> | null
                    : InferResult<Resource, Field[K]>
                : T[K] extends {
                      __type: "ComplexCalculation";
                      __returnType: infer ReturnType;
                    }
                  ? NonNullable<ReturnType> extends TypedSchema
                    ? null extends ReturnType
                      ? InferResult<NonNullable<ReturnType>, Field[K]> | null
                      : InferResult<NonNullable<ReturnType>, Field[K]>
                    : ReturnType
                  : NonNullable<T[K]> extends TypedSchema
                    ? null extends T[K]
                      ? InferResult<NonNullable<T[K]>, Field[K]> | undefined
                      : InferResult<NonNullable<T[K]>, Field[K]>
                    : never
              : never;
          }
        : never;

    type InferResult<
      T extends TypedSchema,
      SelectedFields extends UnifiedFieldSelection<T>[],
    > = UnionToIntersection<
      {
        [K in keyof SelectedFields]: InferFieldValue<T, SelectedFields[K]>;
      }[number]
    >;

    // Legacy type for typed map results (needed for generic actions)
    type InferTypedMapResult<TypedMapSchema, Selection> =
      Selection extends string[]
        ? TypedMapSchema extends Record<string, any>
          ? {
              [K in Selection[number]]: K extends keyof TypedMapSchema
                ? TypedMapSchema[K]
                : never
            }
          : TypedMapSchema
        : TypedMapSchema;

    """
  end

  defp generate_helper_functions do
    """
    // Helper Functions

    /**
     * Gets the CSRF token from the page's meta tag
     * Returns null if no CSRF token is found
     */
    export function getPhoenixCSRFToken(): string | null {
      return document
        ?.querySelector("meta[name='csrf-token']")
        ?.getAttribute("content") || null;
    }

    /**
     * Builds headers object with CSRF token for Phoenix applications
     * Returns headers object with X-CSRF-Token (if available)
     */
    export function buildCSRFHeaders(): Record<string, string> {
      const headers: Record<string, string> = {};

      const csrfToken = getPhoenixCSRFToken();
      if (csrfToken) {
        headers["X-CSRF-Token"] = csrfToken;
      }

      return headers;
    }

    """
  end

  defp generate_rpc_functions(
         resources_and_actions,
         endpoint_process,
         endpoint_validate,
         otp_app,
         resources
       ) do
    # Generate relationship types for all resources
    relationship_types =
      resources
      |> Enum.map(&generate_relationship_types(&1, resources))
      |> Enum.join("\n\n")

    # Generate embedded types for all resources
    embedded_types =
      resources
      |> Enum.map(&generate_embedded_types(&1, resources))
      |> Enum.join("\n\n")

    # Generate functions for each Rpc action
    rpc_functions =
      resources_and_actions
      |> Enum.map(
        &generate_rpc_function(
          &1,
          resources_and_actions,
          endpoint_process,
          endpoint_validate,
          otp_app
        )
      )
      |> Enum.join("\n\n")

    """
    #{relationship_types}

    #{embedded_types}

    #{rpc_functions}
    """
  end

  defp generate_embedded_types(resource, all_resources) do
    resource_name = resource |> Module.split() |> List.last()

    # Check if any resource has this as a single embedded resource
    has_single_embedded? =
      all_resources
      |> Enum.reject(&(&1 == resource))
      |> Enum.any?(fn res ->
        attributes = Ash.Resource.Info.public_attributes(res)

        Enum.any?(attributes, fn attr ->
          AshTypescript.Codegen.is_embedded_resource?(attr.type) and attr.type == resource
        end)
      end)

    # Generate single embedded type
    single_embedded =
      if has_single_embedded? do
        """
          type #{resource_name}Embedded = {
            __resource: #{resource_name}ResourceSchema;
            fields: UnifiedFieldSelection<#{resource_name}ResourceSchema>[];
          };
        """
      else
        ""
      end

    # Check if any resource has this as an array embedded resource
    has_array_embedded? =
      all_resources
      |> Enum.reject(&(&1 == resource))
      |> Enum.any?(fn res ->
        attributes = Ash.Resource.Info.public_attributes(res)

        Enum.any?(attributes, fn attr ->
          case attr.type do
            {:array, embedded_type} ->
              AshTypescript.Codegen.is_embedded_resource?(embedded_type) and
                embedded_type == resource

            _ ->
              false
          end
        end)
      end)

    # Generate array embedded type
    array_embedded =
      if has_array_embedded? do
        """
        type #{resource_name}ArrayEmbedded = {
          __array: true;
          __resource: #{resource_name}ResourceSchema;
          fields: UnifiedFieldSelection<#{resource_name}ResourceSchema>[];
        };
        """
      else
        ""
      end

    if has_single_embedded? or has_array_embedded? do
      Enum.join([single_embedded, array_embedded], "\n")
    else
      ""
    end
  end

  defp generate_relationship_types(resource, all_resources) do
    resource_name = resource |> Module.split() |> List.last()

    has_single_relationship? =
      all_resources
      |> Enum.reject(&(&1 == resource))
      |> Enum.any?(fn res ->
        relationships = Ash.Resource.Info.public_relationships(res)

        Enum.any?(
          relationships,
          &(&1.type in [:belongs_to, :has_one] and &1.destination == resource)
        )
      end)

    # Generate single relationship type
    single_rel =
      if has_single_relationship? do
        """
          type #{resource_name}Relationship = {
            __resource: #{resource_name}ResourceSchema;
            fields: UnifiedFieldSelection<#{resource_name}ResourceSchema>[];
          };
        """
      else
        ""
      end

    has_many_relationship? =
      all_resources
      |> Enum.reject(&(&1 == resource))
      |> Enum.any?(fn res ->
        relationships = Ash.Resource.Info.public_relationships(res)

        Enum.any?(
          relationships,
          &(&1.type in [:has_many, :many_to_many] and &1.destination == resource)
        )
      end)

    # Generate array relationship type
    array_rel =
      if has_many_relationship? do
        """
        type #{resource_name}ArrayRelationship = {
          __array: true;
          __resource: #{resource_name}ResourceSchema;
          fields: UnifiedFieldSelection<#{resource_name}ResourceSchema>[];
        };
        """
      else
        ""
      end

    if has_single_relationship? or has_many_relationship? do
      Enum.join([single_rel, array_rel], "\n")
    else
      ""
    end
  end

  defp generate_rpc_function(
         {resource, action, rpc_action},
         _resources_and_actions,
         endpoint_process,
         endpoint_validate,
         _otp_app
       ) do
    # Convert Rpc action name to formatted function name using output_field_formatter
    rpc_action_name = to_string(rpc_action.name)

    # Generate config type
    config_type = generate_config_type(resource, action, rpc_action_name)

    # Generate result inference type
    result_type = generate_result_type(resource, action, rpc_action_name)

    # Generate payload builder
    payload_builder = generate_payload_builder(resource, rpc_action, action, rpc_action_name)

    # Generate Rpc function
    rpc_function =
      generate_rpc_execution_function(rpc_action, action, rpc_action_name, endpoint_process)

    # Generate validation function (for create, update, destroy actions only)
    validation_function =
      generate_validation_function(
        resource,
        rpc_action,
        action,
        rpc_action_name,
        endpoint_validate
      )

    functions_section =
      if validation_function == "" do
        rpc_function
      else
        """
        #{rpc_function}

        #{validation_function}
        """
      end

    """
    #{config_type}

    #{result_type}

    #{payload_builder}

    #{functions_section}
    """
  end

  # Pagination detection functions - read actual Ash configuration
  def action_supports_pagination?(action) do
    action.type == :read and not action.get? and has_pagination_config?(action)
  end

  defp action_supports_offset_pagination?(action) do
    case get_pagination_config(action) do
      nil -> false
      pagination_config -> Map.get(pagination_config, :offset?, false)
    end
  end

  defp action_supports_keyset_pagination?(action) do
    case get_pagination_config(action) do
      nil -> false
      pagination_config -> Map.get(pagination_config, :keyset?, false)
    end
  end

  defp action_requires_pagination?(action) do
    case get_pagination_config(action) do
      nil -> false
      pagination_config -> Map.get(pagination_config, :required?, false)
    end
  end

  defp action_supports_countable?(action) do
    case get_pagination_config(action) do
      nil -> false
      pagination_config -> Map.get(pagination_config, :countable, false)
    end
  end

  defp action_has_default_limit?(action) do
    case get_pagination_config(action) do
      nil -> false
      pagination_config -> Map.has_key?(pagination_config, :default_limit)
    end
  end

  defp has_pagination_config?(action) do
    case action do
      %{pagination: pagination} when is_map(pagination) -> true
      _ -> false
    end
  end

  defp get_pagination_config(action) do
    case action do
      %{pagination: pagination} when is_map(pagination) -> pagination
      _ -> nil
    end
  end

  # Helper to detect if a generic action returns a type that supports field selection
  def action_returns_field_selectable_type?(action) do
    case action.returns do
      # Array of structs (resources)
      {:array, Ash.Type.Struct} ->
        items_constraints = Keyword.get(action.constraints || [], :items, [])

        if Keyword.has_key?(items_constraints, :instance_of) do
          {:ok, :array_of_resource, Keyword.get(items_constraints, :instance_of)}
        else
          {:error, :no_instance_of_defined}
        end

      # Array of maps (typed maps with field definitions)
      {:array, Ash.Type.Map} ->
        items_constraints = Keyword.get(action.constraints || [], :items, [])

        if Keyword.has_key?(items_constraints, :fields) do
          {:ok, :array_of_typed_map, Keyword.get(items_constraints, :fields)}
        else
          {:error, :no_fields_defined}
        end

      # Single struct (resource)
      Ash.Type.Struct ->
        constraints = action.constraints || []

        if Keyword.has_key?(constraints, :instance_of) do
          {:ok, :resource, Keyword.get(constraints, :instance_of)}
        else
          {:error, :no_instance_of_defined}
        end

      # Single map (typed map with field definitions)
      Ash.Type.Map ->
        constraints = action.constraints || []

        if Keyword.has_key?(constraints, :fields) do
          {:ok, :typed_map, Keyword.get(constraints, :fields)}
        else
          {:error, :no_fields_defined}
        end

      _ ->
        {:error, :not_field_selectable_type}
    end
  end

  # Generate a TypeScript schema from typed map field constraints
  defp generate_typed_map_schema(fields) do
    field_definitions =
      Enum.map(fields, fn {field_name, field_config} ->
        # Create a type descriptor that AshTypescript.Codegen.get_ts_type can handle
        type_descriptor = %{
          type: Keyword.get(field_config, :type),
          constraints: Keyword.get(field_config, :constraints, []),
          allow_nil?: Keyword.get(field_config, :allow_nil?, false)
        }

        field_type = AshTypescript.Codegen.get_ts_type(type_descriptor)

        "#{field_name}: #{field_type}"
      end)

    "{ #{Enum.join(field_definitions, ", ")} }"
  end

  defp generate_pagination_fields_only(action) do
    if action_supports_pagination?(action) do
      generate_pagination_fields(action)
    else
      []
    end
  end

  defp generate_pagination_fields(action) do
    supports_offset = action_supports_offset_pagination?(action)
    supports_keyset = action_supports_keyset_pagination?(action)
    supports_countable = action_supports_countable?(action)
    is_required = action_requires_pagination?(action)
    has_default_limit = action_has_default_limit?(action)

    if supports_offset or supports_keyset do
      optional_mark = if is_required, do: "", else: "?"
      limit_required = if is_required and not has_default_limit, do: "", else: "?"

      cond do
        supports_offset and supports_keyset ->
          # Generate union type for mixed pagination support
          generate_mixed_pagination_fields(limit_required, supports_countable, optional_mark)

        supports_offset ->
          # Generate offset-only pagination interface
          generate_offset_pagination_fields(limit_required, supports_countable, optional_mark)

        supports_keyset ->
          # Generate keyset-only pagination interface
          generate_keyset_pagination_fields(limit_required, optional_mark)
      end
    else
      []
    end
  end

  defp generate_offset_pagination_fields(limit_required, supports_countable, optional_mark) do
    fields = ["    limit#{limit_required}: number;", "    offset?: number;"]

    fields =
      if supports_countable do
        fields ++ ["    count?: boolean;"]
      else
        fields
      end

    [
      "  page#{optional_mark}: {"
    ] ++
      fields ++
      [
        "  };"
      ]
  end

  defp generate_keyset_pagination_fields(limit_required, optional_mark) do
    fields = [
      "    limit#{limit_required}: number;",
      "    after?: string;",
      "    before?: string;"
    ]

    [
      "  page#{optional_mark}: {"
    ] ++
      fields ++
      [
        "  };"
      ]
  end

  defp generate_mixed_pagination_fields(limit_required, supports_countable, optional_mark) do
    # Generate union type for mixed pagination support (without type discriminator)
    offset_fields = [
      "      limit#{limit_required}: number;",
      "      offset?: number;"
    ]

    offset_fields =
      if supports_countable do
        offset_fields ++ ["      count?: boolean;"]
      else
        offset_fields
      end

    keyset_fields = [
      "      limit#{limit_required}: number;",
      "      after?: string;",
      "      before?: string;"
    ]

    keyset_fields =
      if supports_countable do
        keyset_fields ++ ["      count?: boolean;"]
      else
        keyset_fields
      end

    [
      "  page#{optional_mark}:"
    ] ++
      [
        "    | {"
      ] ++
      offset_fields ++
      [
        "    }"
      ] ++
      [
        "    | {"
      ] ++
      keyset_fields ++
      [
        "    };"
      ]
  end

  defp generate_pagination_result_type(_resource, action, rpc_action_name_pascal, resource_name) do
    supports_offset = action_supports_offset_pagination?(action)
    supports_keyset = action_supports_keyset_pagination?(action)

    cond do
      supports_offset and supports_keyset ->
        # Generate union type for mixed pagination support
        generate_mixed_pagination_result_type(rpc_action_name_pascal, resource_name)

      supports_offset ->
        # Generate offset-only pagination result type
        generate_offset_pagination_result_type(rpc_action_name_pascal, resource_name)

      supports_keyset ->
        # Generate keyset-only pagination result type
        generate_keyset_pagination_result_type(rpc_action_name_pascal, resource_name)
    end
  end

  defp generate_offset_pagination_result_type(rpc_action_name_pascal, resource_name) do
    formatter = AshTypescript.Rpc.output_field_formatter()
    results_field = AshTypescript.FieldFormatter.format_field("results", formatter)
    has_more_field = AshTypescript.FieldFormatter.format_field("has_more", formatter)
    limit_field = AshTypescript.FieldFormatter.format_field("limit", formatter)
    offset_field = AshTypescript.FieldFormatter.format_field("offset", formatter)

    """
    type Infer#{rpc_action_name_pascal}Result<Config extends #{rpc_action_name_pascal}Config> =
      Config extends { page: any; }
        ? {
            #{results_field}: Array<InferResult<#{resource_name}ResourceSchema, Config["fields"]>>;
            #{has_more_field}: boolean;
            #{limit_field}: number;
            #{offset_field}: number;
          }
        : Array<InferResult<#{resource_name}ResourceSchema, Config["fields"]>>;
    """
  end

  defp generate_keyset_pagination_result_type(rpc_action_name_pascal, resource_name) do
    formatter = AshTypescript.Rpc.output_field_formatter()
    results_field = AshTypescript.FieldFormatter.format_field("results", formatter)
    has_more_field = AshTypescript.FieldFormatter.format_field("has_more", formatter)
    limit_field = AshTypescript.FieldFormatter.format_field("limit", formatter)
    after_field = AshTypescript.FieldFormatter.format_field("after", formatter)
    before_field = AshTypescript.FieldFormatter.format_field("before", formatter)
    previous_page_field = AshTypescript.FieldFormatter.format_field("previous_page", formatter)
    next_page_field = AshTypescript.FieldFormatter.format_field("next_page", formatter)

    """
    type Infer#{rpc_action_name_pascal}Result<Config extends #{rpc_action_name_pascal}Config> =
      Config extends { page: any; }
        ? {
            #{results_field}: Array<InferResult<#{resource_name}ResourceSchema, Config["fields"]>>;
            #{has_more_field}: boolean;
            #{limit_field}: number;
            #{after_field}: string | null;
            #{before_field}: string | null;
            #{previous_page_field}: string;
            #{next_page_field}: string;
          }
        : Array<InferResult<#{resource_name}ResourceSchema, Config["fields"]>>;
    """
  end

  defp generate_mixed_pagination_result_type(rpc_action_name_pascal, resource_name) do
    formatter = AshTypescript.Rpc.output_field_formatter()
    results_field = AshTypescript.FieldFormatter.format_field("results", formatter)
    has_more_field = AshTypescript.FieldFormatter.format_field("has_more", formatter)
    limit_field = AshTypescript.FieldFormatter.format_field("limit", formatter)
    offset_field = AshTypescript.FieldFormatter.format_field("offset", formatter)
    after_field = AshTypescript.FieldFormatter.format_field("after", formatter)
    before_field = AshTypescript.FieldFormatter.format_field("before", formatter)
    count_field = AshTypescript.FieldFormatter.format_field("count", formatter)
    previous_page_field = AshTypescript.FieldFormatter.format_field("previous_page", formatter)
    next_page_field = AshTypescript.FieldFormatter.format_field("next_page", formatter)
    type_field = AshTypescript.FieldFormatter.format_field("type", formatter)

    """
    type Infer#{rpc_action_name_pascal}Result<Config extends #{rpc_action_name_pascal}Config> =
      Config extends { page: any; }
        ? ({
            #{results_field}: Array<InferResult<#{resource_name}ResourceSchema, Config["fields"]>>;
            #{has_more_field}: boolean;
            #{limit_field}: number;
            #{offset_field}: number;
            #{count_field}?: number | null;
            #{type_field}: "offset";
          } | {
            #{results_field}: Array<InferResult<#{resource_name}ResourceSchema, Config["fields"]>>;
            #{has_more_field}: boolean;
            #{limit_field}: number;
            #{after_field}: string | null;
            #{before_field}: string | null;
            #{previous_page_field}: string;
            #{next_page_field}: string;
            #{count_field}?: number | null;
            #{type_field}: "keyset";
          })
        : Array<InferResult<#{resource_name}ResourceSchema, Config["fields"]>>;
    """
  end

  defp generate_config_type(resource, action, rpc_action_name) do
    resource_name = resource |> Module.split() |> List.last()
    config_name = "#{snake_to_pascal_case(rpc_action_name)}Config"

    # Add tenant field if resource requires tenant
    tenant_field =
      if AshTypescript.Rpc.requires_tenant_parameter?(resource) do
        ["  tenant: string;"]
      else
        []
      end

    # Base config fields - use formatted field names
    formatted_fields_name =
      AshTypescript.FieldFormatter.format_field(
        "fields",
        AshTypescript.Rpc.output_field_formatter()
      )

    fields_field = [
      "  #{formatted_fields_name}: UnifiedFieldSelection<#{resource_name}ResourceSchema>[];"
    ]

    # Add headers field (optional)
    headers_field = [
      "  headers?: Record<string, string>;"
    ]

    # Add input fields based on action type
    input_fields =
      case action.type do
        :read ->
          # For read actions, only use arguments (get_by automatically creates arguments)
          arguments = action.arguments

          if arguments != [] do
            # Generate input field definitions from arguments
            argument_field_defs =
              Enum.map(arguments, fn arg ->
                optional = arg.allow_nil? || arg.default != nil

                formatted_arg_name =
                  AshTypescript.FieldFormatter.format_field(
                    arg.name,
                    AshTypescript.Rpc.output_field_formatter()
                  )

                {formatted_arg_name, get_ts_type(arg), optional}
              end)

            # Check if ALL arguments are optional
            all_optional =
              Enum.all?(argument_field_defs, fn {_name, _type, optional} -> optional end)

            input_property = if all_optional, do: "  input?: {", else: "  input: {"

            field_lines =
              Enum.map(argument_field_defs, fn {name, type, optional} ->
                "    #{name}#{if optional, do: "?", else: ""}: #{type};"
              end)

            [input_property] ++ field_lines ++ ["  };"]
          else
            []
          end

        :create ->
          accepts = Ash.Resource.Info.action(resource, action.name).accept || []
          arguments = action.arguments

          if accepts != [] || arguments != [] do
            # Generate input field definitions
            accept_field_defs =
              Enum.map(accepts, fn field_name ->
                attr = Ash.Resource.Info.attribute(resource, field_name)
                optional = attr.allow_nil? || attr.default != nil
                base_type = AshTypescript.Codegen.get_ts_input_type(attr)
                field_type = if attr.allow_nil?, do: "#{base_type} | null", else: base_type

                formatted_field_name =
                  AshTypescript.FieldFormatter.format_field(
                    field_name,
                    AshTypescript.Rpc.output_field_formatter()
                  )

                {formatted_field_name, field_type, optional}
              end)

            argument_field_defs =
              Enum.map(arguments, fn arg ->
                optional = arg.allow_nil? || arg.default != nil

                formatted_arg_name =
                  AshTypescript.FieldFormatter.format_field(
                    arg.name,
                    AshTypescript.Rpc.output_field_formatter()
                  )

                {formatted_arg_name, get_ts_type(arg), optional}
              end)

            all_input_fields = accept_field_defs ++ argument_field_defs

            # Check if ALL fields are optional
            all_optional =
              Enum.all?(all_input_fields, fn {_name, _type, optional} -> optional end)

            input_property = if all_optional, do: "  input?: {", else: "  input: {"

            field_lines =
              Enum.map(all_input_fields, fn {name, type, optional} ->
                "    #{name}#{if optional, do: "?", else: ""}: #{type};"
              end)

            [input_property] ++ field_lines ++ ["  };"]
          else
            []
          end

        action_type when action_type in [:update, :destroy] ->
          primary_key_attrs = Ash.Resource.Info.primary_key(resource)

          primary_key_field =
            if Enum.count(primary_key_attrs) == 1 do
              attr_name = Enum.at(primary_key_attrs, 0)
              attr = Ash.Resource.Info.attribute(resource, attr_name)
              ["  primaryKey: #{get_ts_type(attr)};"]
            else
              ["  primaryKey: {"] ++
                Enum.map(primary_key_attrs, fn attr_name ->
                  attr = Ash.Resource.Info.attribute(resource, attr_name)
                  "    #{attr.name}: #{get_ts_type(attr)};"
                end) ++
                ["  };"]
            end

          input_fields =
            if action.accept != [] || action.arguments != [] do
              ["  input: {"] ++
                Enum.map(action.accept, fn field_name ->
                  attr = Ash.Resource.Info.attribute(resource, field_name)

                  formatted_field_name =
                    AshTypescript.FieldFormatter.format_field(
                      field_name,
                      AshTypescript.Rpc.output_field_formatter()
                    )

                  if attr.allow_nil? do
                    "    #{formatted_field_name}?: #{AshTypescript.Codegen.get_ts_input_type(attr)} | null;"
                  else
                    "    #{formatted_field_name}: #{AshTypescript.Codegen.get_ts_input_type(attr)};"
                  end
                end) ++
                Enum.map(action.arguments, fn arg ->
                  optional = arg.allow_nil? || arg.default != nil

                  formatted_arg_name =
                    AshTypescript.FieldFormatter.format_field(
                      arg.name,
                      AshTypescript.Rpc.output_field_formatter()
                    )

                  "    #{formatted_arg_name}#{if optional, do: "?", else: ""}: #{get_ts_type(arg)};"
                end) ++
                ["  };"]
            else
              []
            end

          primary_key_field ++ input_fields

        :action ->
          arguments = action.arguments

          input_fields =
            if arguments != [] do
              ["  input: {"] ++
                Enum.map(arguments, fn arg ->
                  optional = arg.allow_nil? || arg.default != nil

                  formatted_arg_name =
                    AshTypescript.FieldFormatter.format_field(
                      arg.name,
                      AshTypescript.Rpc.output_field_formatter()
                    )

                  "    #{formatted_arg_name}#{if optional, do: "?", else: ""}: #{get_ts_type(arg)};"
                end) ++
                ["  };"]
            else
              []
            end

          # Check if this generic action returns a field-selectable type
          case action_returns_field_selectable_type?(action) do
            {:ok, type, _value} when type in [:resource, :array_of_resource] ->
              # For resources, use the standard resource schema field selection
              input_fields ++ fields_field

            {:ok, type, fields} when type in [:typed_map, :array_of_typed_map] ->
              # For typed maps, use a custom field selection for the map's fields
              typed_map_field_names =
                Enum.map(fields, fn {field_name, _} -> Atom.to_string(field_name) end)

              typed_map_fields = [
                "  fields: (\"#{Enum.join(typed_map_field_names, "\" | \"")}\")[];"
              ]

              input_fields ++ typed_map_fields

            _ ->
              input_fields
          end
      end

    all_fields =
      case action.type do
        :read ->
          # Generate read-specific fields (filters and pagination)
          filters =
            if action.get? do
              []
            else
              [
                "  filter?: #{resource_name}FilterInput;"
              ]
            end

          # Generate sort and pagination separately
          sort_fields = if not action.get?, do: ["  sort?: string;"], else: []
          pagination_fields = generate_pagination_fields_only(action)
          pagination_and_sort = sort_fields ++ pagination_fields

          tenant_field ++
            input_fields ++ filters ++ pagination_and_sort ++ fields_field ++ headers_field

        action_type when action_type in [:create, :update] ->
          tenant_field ++ input_fields ++ fields_field ++ headers_field

        :destroy ->
          tenant_field ++ input_fields ++ headers_field

        _ ->
          # This shouldn't happen but keep as fallback
          tenant_field ++ input_fields ++ headers_field
      end

    """
    export type #{config_name} = {
    #{Enum.join(all_fields, "\n")}
    };
    """
  end

  defp generate_result_type(resource, action, rpc_action_name) do
    resource_name = resource |> Module.split() |> List.last()
    rpc_action_name_pascal = snake_to_pascal_case(rpc_action_name)

    case action.type do
      :read when action.get? ->
        """
        type Infer#{rpc_action_name_pascal}Result<Config extends #{rpc_action_name_pascal}Config> =
          InferResult<#{resource_name}ResourceSchema, Config["fields"]> | null;
        """

      :read ->
        # Check if action supports pagination to determine return type
        if action_supports_pagination?(action) do
          generate_pagination_result_type(resource, action, rpc_action_name_pascal, resource_name)
        else
          """
          type Infer#{rpc_action_name_pascal}Result<Config extends #{rpc_action_name_pascal}Config> =
            Array<InferResult<#{resource_name}ResourceSchema, Config["fields"]>>;
          """
        end

      action_type when action_type in [:create, :update] ->
        """
        type Infer#{rpc_action_name_pascal}Result<Config extends #{rpc_action_name_pascal}Config> =
          InferResult<#{resource_name}ResourceSchema, Config["fields"]>;
        """

      :destroy ->
        # No result type needed - function signatures use void directly
        ""

      :action ->
        # Check if generic action returns a field-selectable type
        case action_returns_field_selectable_type?(action) do
          {:ok, type, value} when type in [:resource, :array_of_resource] ->
            # For resources, use the resource's schema for field selection
            target_resource_name = value |> Module.split() |> List.last()

            if type == :array_of_resource do
              """
              type Infer#{rpc_action_name_pascal}Result<Config extends #{rpc_action_name_pascal}Config> =
                Array<InferResult<#{target_resource_name}ResourceSchema, Config["fields"]>>;
              """
            else
              """
              type Infer#{rpc_action_name_pascal}Result<Config extends #{rpc_action_name_pascal}Config> =
                InferResult<#{target_resource_name}ResourceSchema, Config["fields"]>;
              """
            end

          {:ok, type, fields} when type in [:typed_map, :array_of_typed_map] ->
            # For typed maps, generate a field-selectable schema
            typed_map_schema = generate_typed_map_schema(fields)

            if type == :array_of_typed_map do
              """
              type Infer#{rpc_action_name_pascal}Result<Config extends #{rpc_action_name_pascal}Config> =
                Array<InferTypedMapResult<#{typed_map_schema}, Config["fields"]>>;
              """
            else
              """
              type Infer#{rpc_action_name_pascal}Result<Config extends #{rpc_action_name_pascal}Config> =
                InferTypedMapResult<#{typed_map_schema}, Config["fields"]>;
              """
            end

          _ ->
            # Non-field-selectable types or no return type
            if action.returns do
              return_type = get_ts_type(%{type: action.returns, constraints: action.constraints})

              """
              type Infer#{rpc_action_name_pascal}Result = #{return_type};
              """
            else
              """
              type Infer#{rpc_action_name_pascal}Result = {};
              """
            end
        end
    end
  end

  defp generate_payload_builder(resource, _rpc_action, action, rpc_action_name) do
    rpc_action_name_pascal = snake_to_pascal_case(rpc_action_name)

    # Base payload construction with tenant handling
    formatted_fields_name =
      AshTypescript.FieldFormatter.format_field(
        "fields",
        AshTypescript.Rpc.output_field_formatter()
      )

    base_payload_with_tenant = fn ->
      if AshTypescript.Rpc.requires_tenant_parameter?(resource) do
        """
          const payload: Record<string, any> = {
            action: "#{rpc_action_name}",
            tenant: config.tenant,
            fields: config.#{formatted_fields_name}
          };
        """
      else
        """
          const payload: Record<string, any> = {
            action: "#{rpc_action_name}",
            fields: config.#{formatted_fields_name}
          };
        """
      end
    end

    cond do
      # Read actions with pagination support
      action.type == :read and not action.get? and action_supports_pagination?(action) ->
        """
        export function build#{rpc_action_name_pascal}Payload(
          config: #{rpc_action_name_pascal}Config
        ): Record<string, any> {
        #{base_payload_with_tenant.()}

          if (config.filter) {
            payload.filter = config.filter;
          } else {
            payload.filter = {};
          }

          if (config.page) {
            payload.page = config.page;
          }

          if (config.sort) {
            payload.sort = config.sort;
          }

          if ("input" in config && config.input) {
            payload.input = config.input;
          } else {
            payload.input = {};
          }

          return payload;
        }
        """

      # Read actions without pagination support
      action.type == :read and not action.get? and not action_supports_pagination?(action) ->
        """
        export function build#{rpc_action_name_pascal}Payload(
          config: #{rpc_action_name_pascal}Config
        ): Record<string, any> {
        #{base_payload_with_tenant.()}

          if (config.filter) {
            payload.filter = config.filter;
          } else {
            payload.filter = {};
          }

          if (config.sort) {
            payload.sort = config.sort;
          }

          if ("input" in config && config.input) {
            payload.input = config.input;
          } else {
            payload.input = {};
          }

          return payload;
        }
        """

      action.type == :read and action.get? ->
        """
        export function build#{rpc_action_name_pascal}Payload(
          config: #{rpc_action_name_pascal}Config
        ): Record<string, any> {
        #{base_payload_with_tenant.()}

          if ("input" in config && config.input) {
            payload.input = config.input;
          } else {
            payload.input = {};
          }

          return payload;
        }
        """

      action.type == :create ->
        """
        export function build#{rpc_action_name_pascal}Payload(
          config: #{rpc_action_name_pascal}Config
        ): Record<string, any> {
        #{base_payload_with_tenant.()}

          if ("input" in config && config.input) {
            payload.input = config.input;
          } else {
            payload.input = {};
          }

          return payload;
        }
        """

      action.type == :update ->
        update_payload_base =
          if AshTypescript.Rpc.requires_tenant_parameter?(resource) do
            """
            const payload: Record<string, any> = {
              action: "#{rpc_action_name}",
              tenant: config.tenant,
              fields: config.#{formatted_fields_name},
              primary_key: config.primaryKey
            };
            """
          else
            """
            const payload: Record<string, any> = {
              action: "#{rpc_action_name}",
              fields: config.#{formatted_fields_name},
              primary_key: config.primaryKey
            };
            """
          end

        """
        export function build#{rpc_action_name_pascal}Payload(
          config: #{rpc_action_name_pascal}Config
        ): Record<string, any> {
        #{update_payload_base}

          if ("input" in config && config.input) {
            payload.input = config.input;
          } else {
            payload.input = {};
          }

          return payload;
        }
        """

      action.type == :destroy ->
        destroy_payload_base =
          if AshTypescript.Rpc.requires_tenant_parameter?(resource) do
            """
            const payload: Record<string, any> = {
              action: "#{rpc_action_name}",
              tenant: config.tenant,
              primary_key: config.primaryKey
            };
            """
          else
            """
            const payload: Record<string, any> = {
              action: "#{rpc_action_name}",
              primary_key: config.primaryKey
            };
            """
          end

        """
        export function build#{rpc_action_name_pascal}Payload(
          config: #{rpc_action_name_pascal}Config
        ): Record<string, any> {
        #{destroy_payload_base}

          if ("input" in config && config.input) {
            payload.input = config.input;
          } else {
            payload.input = {};
          }

          return payload;
        }
        """

      action.type == :action ->
        # Check if this generic action supports field selection
        has_field_selection = match?({:ok, _, _}, action_returns_field_selectable_type?(action))

        action_payload_base =
          if has_field_selection do
            # Include fields in the payload for field-selectable generic actions
            if AshTypescript.Rpc.requires_tenant_parameter?(resource) do
              """
              const payload: Record<string, any> = {
                action: "#{rpc_action_name}",
                tenant: config.tenant,
                fields: config.#{formatted_fields_name}
              };
              """
            else
              """
              const payload: Record<string, any> = {
                action: "#{rpc_action_name}",
                fields: config.#{formatted_fields_name}
              };
              """
            end
          else
            # No field selection for non-field-selectable generic actions
            if AshTypescript.Rpc.requires_tenant_parameter?(resource) do
              """
              const payload: Record<string, any> = {
                action: "#{rpc_action_name}",
                tenant: config.tenant
              };
              """
            else
              """
              const payload: Record<string, any> = {
                action: "#{rpc_action_name}"
              };
              """
            end
          end

        """
        export function build#{rpc_action_name_pascal}Payload(
          config: #{rpc_action_name_pascal}Config
        ): Record<string, any> {
        #{action_payload_base}

          if ("input" in config && config.input) {
            payload.input = config.input;
          } else {
            payload.input = {};
          }

          return payload;
        }
        """
    end
  end

  defp generate_rpc_execution_function(_rpc_action, action, rpc_action_name, endpoint_process) do
    function_name =
      AshTypescript.FieldFormatter.format_field(
        rpc_action_name,
        AshTypescript.Rpc.output_field_formatter()
      )

    # Add proper type handling for different action types
    is_generic_action = action.type in [:action, :generic]

    is_field_selectable_generic =
      is_generic_action && match?({:ok, _, _}, action_returns_field_selectable_type?(action))

    rpc_action_name_pascal = snake_to_pascal_case(rpc_action_name)

    {result_type, result_type_def, return_type_def} =
      cond do
        action.type == :destroy ->
          result_type = """
          {success: true, data: {}} |
          {success: false, errors: Array<{type: string, message: string, field_path?: string, details: Record<string, string>}>}
          """

          result_type_def =
            "export type #{rpc_action_name_pascal}Result = #{result_type};"

          {result_type, result_type_def, "#{rpc_action_name_pascal}Result;"}

        is_field_selectable_generic ->
          # Generic actions with field selection need Config parameter
          result_type = """
            {success: true, data: Infer#{rpc_action_name_pascal}Result<Config>} |
            {success: false, errors: Array<{type: string, message: string, field_path?: string, details: Record<string, string>}>}
          """

          result_type_def =
            "export type #{rpc_action_name_pascal}Result<Config extends #{rpc_action_name_pascal}Config> = #{result_type};"

          {result_type, result_type_def, "#{rpc_action_name_pascal}Result<Config>;"}

        is_generic_action ->
          # Generic actions without field selection
          result_type = """
          {success: true, data: Infer#{rpc_action_name_pascal}Result} |
          {success: false, errors: Array<{type: string, message: string, field_path?: string, details: Record<string, string>}>}
          """

          result_type_def =
            "export type #{rpc_action_name_pascal}Result = #{result_type};"

          {result_type, result_type_def, "#{rpc_action_name_pascal}Result;"}

        true ->
          # Standard CRUD actions with field selection
          result_type = """
            {success: true, data: Infer#{rpc_action_name_pascal}Result<Config>} |
            {success: false, errors: Array<{type: string, message: string, field_path?: string, details: Record<string, string>}>}
          """

          result_type_def =
            "export type #{rpc_action_name_pascal}Result<Config extends #{rpc_action_name_pascal}Config> = #{result_type};"

          {result_type, result_type_def, "#{rpc_action_name_pascal}Result<Config>;"}
      end

    """
    #{result_type_def}

    export async function #{function_name}<Config extends #{rpc_action_name_pascal}Config>(
      config: Config
    ): Promise<#{result_type}> {
      const payload = build#{rpc_action_name_pascal}Payload(config);

      const headers: Record<string, string> = {
        "Content-Type": "application/json",
        ...config.headers,
      };

      const response = await fetch("#{endpoint_process}", {
        method: "POST",
        headers,
        body: JSON.stringify(payload),
      });

      if (!response.ok) {
        return {success: false, errors: [
          {type: 'network', message: response.statusText, details: {}}
        ]};
      }

      const result = await response.json()
      return result as #{return_type_def}
    }
    """
  end

  defp generate_validation_function(
         resource,
         rpc_action,
         action,
         rpc_action_name,
         endpoint_validate
       ) do
    # Only generate validation functions for create, update, and destroy actions
    case action.type do
      :read ->
        ""

      :action ->
        ""

      _ ->
        # Convert Rpc action name using output formatter and add validate prefix
        validation_function_name =
          AshTypescript.FieldFormatter.format_field(
            "validate_" <> rpc_action_name,
            AshTypescript.Rpc.output_field_formatter()
          )

        primary_key_field_name =
          AshTypescript.FieldFormatter.format_field(
            "primary_key",
            AshTypescript.Rpc.output_field_formatter()
          )

        # Keep pascal case for config type references (TypeScript convention)
        rpc_action_name_pascal = AshTypescript.Helpers.snake_to_pascal_case(rpc_action_name)

        # Determine if we need primary_key parameter
        needs_primary_key = action.type in [:update, :destroy]

        # Check if action has input parameters
        has_input = length(action.accept) > 0 or length(action.arguments) > 0

        # Check if resource requires tenant
        requires_tenant = AshTypescript.Rpc.requires_tenant_parameter?(resource)

        # Build function signature including tenant parameter when needed
        base_params =
          case {needs_primary_key, has_input} do
            {true, true} ->
              [
                "#{primary_key_field_name}: string | number",
                "input: #{rpc_action_name_pascal}Config[\"input\"]"
              ]

            {true, false} ->
              ["#{primary_key_field_name}: string | number"]

            {false, true} ->
              ["input: #{rpc_action_name_pascal}Config[\"input\"]"]

            {false, false} ->
              []
          end

        all_params =
          if requires_tenant do
            ["tenant: string"] ++ base_params
          else
            base_params
          end

        params = Enum.join(all_params, ", ")

        # Build payload construction
        base_payload =
          if requires_tenant do
            ["action: \"#{rpc_action.name}\"", "tenant: tenant"]
          else
            ["action: \"#{rpc_action.name}\""]
          end

        payload_with_pk =
          if needs_primary_key do
            base_payload ++ ["primary_key: #{primary_key_field_name}"]
          else
            base_payload
          end

        payload_lines =
          if has_input do
            payload_with_pk ++ ["input: input"]
          else
            payload_with_pk ++ ["input: {}"]
          end

        payload_content = Enum.join(payload_lines, ",\n    ")

        """
        export async function #{validation_function_name}(#{params}, headers?: Record<string, string>): Promise<{
          success: boolean;
          errors?: Record<string, string[]>;
        }> {
          const payload = {
            #{payload_content}
          };

          const requestHeaders: Record<string, string> = {
            "Content-Type": "application/json",
            ...headers,
          };

          const response = await fetch("#{endpoint_validate}", {
            method: "POST",
            headers: requestHeaders,
            body: JSON.stringify(payload),
          });

          if (!response.ok) {
            throw new Error(`Validation call failed: ${response.statusText}`);
          }

          const result = await response.json();

          if (result.success) {
            return { success: true };
          } else {
            return { success: false, errors: result.errors };
          }
        }
        """
    end
  end

  @doc """
  Generates TypedStruct schemas for field selection.
  Creates separate typedStructs schema section with field selection arrays.
  """
  def generate_typed_structs_schemas(resources) do
    typed_structs = AshTypescript.Codegen.find_typed_structs(resources)

    # Always generate resource-level TypedStruct schemas (empty for resources without TypedStruct)
    resource_schemas =
      resources
      |> Enum.map(&generate_typed_struct_schema_for_resource/1)
      |> Enum.join("\n\n")

    # Only generate individual TypedStruct schemas if TypedStruct modules exist
    individual_schemas =
      if Enum.empty?(typed_structs) do
        ""
      else
        typed_structs
        |> Enum.map(&generate_individual_typed_struct_schemas/1)
        |> Enum.filter(&(&1 != ""))
        |> Enum.join("\n\n")
      end

    schemas =
      [resource_schemas, individual_schemas]
      |> Enum.filter(&(&1 != ""))
      |> Enum.join("\n\n")

    if schemas == "" do
      ""
    else
      """
      // TypedStruct Schemas
      #{schemas}
      """
    end
  end

  defp generate_typed_struct_schema_for_resource(resource) do
    typed_struct_fields = get_typed_struct_fields_for_resource(resource)
    resource_name = resource |> Module.split() |> List.last()

    if Enum.empty?(typed_struct_fields) do
      "type #{resource_name}TypedStructsSchema = {};"
    else
      field_entries =
        typed_struct_fields
        |> Enum.map(fn {field_name, _typed_struct_module} ->
          field_name_str = Atom.to_string(field_name)
          "  #{field_name_str}: string[];"
        end)
        |> Enum.join("\n")

      """
      type #{resource_name}TypedStructsSchema = {
      #{field_entries}
      };
      """
    end
  end

  defp get_typed_struct_fields_for_resource(resource) do
    resource
    |> Ash.Resource.Info.public_attributes()
    |> Enum.filter(fn attr ->
      case attr.type do
        module when is_atom(module) -> AshTypescript.Codegen.is_typed_struct?(module)
        {:array, module} when is_atom(module) -> AshTypescript.Codegen.is_typed_struct?(module)
        _ -> false
      end
    end)
    |> Enum.map(fn attr ->
      typed_struct_module =
        case attr.type do
          module when is_atom(module) -> module
          {:array, module} when is_atom(module) -> module
          _ -> nil
        end

      {attr.name, typed_struct_module}
    end)
    |> Enum.filter(fn {_name, module} -> module != nil end)
  end

  defp generate_individual_typed_struct_schemas(typed_struct_module) do
    module_name = typed_struct_module |> Module.split() |> List.last()

    # Get TypedStruct field information
    fields = AshTypescript.Codegen.get_typed_struct_fields(typed_struct_module)

    if Enum.empty?(fields) do
      ""
    else
      # Generate field selection type (for unions and field selection)
      field_selection_type = """
      type #{module_name}TypedStructFieldSelection = string[];
      """

      # Generate individual field schemas (for type inference)
      field_schema_entries =
        fields
        |> Enum.map(fn %{name: field_name, type: field_type} ->
          ts_type = get_typed_struct_field_ts_type(field_type)
          "  #{field_name}: #{ts_type};"
        end)
        |> Enum.join("\n")

      field_schema_type = """
      type #{module_name}TypedStructSchema = {
      #{field_schema_entries}
      };
      """

      # Generate input schema (for create/update operations)
      input_schema_entries =
        fields
        |> Enum.map(fn %{name: field_name, type: field_type, constraints: constraints} ->
          ts_type = get_typed_struct_field_ts_type(field_type)

          is_optional =
            Keyword.get(constraints, :allow_nil?, false) ||
              Keyword.get(constraints, :default) != nil

          optional_marker = if is_optional, do: "?", else: ""
          "  #{field_name}#{optional_marker}: #{ts_type};"
        end)
        |> Enum.join("\n")

      input_schema_type = """
      type #{module_name}TypedStructInputSchema = {
      #{input_schema_entries}
      };
      """

      [field_selection_type, field_schema_type, input_schema_type]
      |> Enum.join("\n")
    end
  end

  defp get_typed_struct_field_ts_type(field_type) do
    # Map Ash types to TypeScript types for TypedStruct fields
    case field_type do
      :string -> "string"
      :integer -> "number"
      :float -> "number"
      :boolean -> "boolean"
      :utc_datetime -> "string"
      :date -> "string"
      :time -> "string"
      :decimal -> "number"
      :uuid -> "string"
      {:array, inner_type} -> "Array<#{get_typed_struct_field_ts_type(inner_type)}>"
      _ -> "any"
    end
  end

  defp generate_typed_queries_section([], _all_resources), do: ""

  defp generate_typed_queries_section(typed_queries, all_resources) do
    # Group typed queries by resource for better organization
    queries_by_resource =
      Enum.group_by(typed_queries, fn {resource, _action, _query} -> resource end)

    sections =
      Enum.map(queries_by_resource, fn {resource, queries} ->
        resource_name = resource |> Module.split() |> List.last()

        query_types_and_consts =
          Enum.map(queries, fn {resource, action, typed_query} ->
            generate_typed_query_type_and_const(resource, action, typed_query, all_resources)
          end)

        """
        // #{resource_name} Typed Queries
        #{Enum.join(query_types_and_consts, "\n\n")}
        """
      end)

    """
    // ============================
    // Typed Queries
    // ============================
    // Use these types and field constants for server-side rendering and data fetching.
    // The field constants can be used with the corresponding RPC actions for client-side refetching.

    #{Enum.join(sections, "\n\n")}
    """
  end

  defp generate_typed_query_type_and_const(resource, action, typed_query, _all_resources) do
    resource_name = resource |> Module.split() |> List.last()

    # Process fields to get the template
    atomized_fields = RequestedFieldsProcessor.atomize_requested_fields(typed_query.fields)

    case RequestedFieldsProcessor.process(resource, action.name, atomized_fields) do
      {:ok, {_select, _load, _template}} ->
        # Format the original fields for both type and constant (preserves args structure)
        const_fields = format_fields_for_typescript(atomized_fields)

        # Generate the type
        type_name = typed_query.ts_result_type_name
        const_name = typed_query.ts_fields_const_name

        # Check if action returns array or single result
        is_array = action.type == :read && !action.get?

        result_type =
          if is_array do
            "Array<InferResult<#{resource_name}ResourceSchema, #{const_fields}>>"
          else
            "InferResult<#{resource_name}ResourceSchema, #{const_fields}>"
          end

        """
        // Type for #{typed_query.name}
        export type #{type_name} = #{result_type};

        // Field selection for #{typed_query.name} - use with RPC actions for refetching
        export const #{const_name} = #{const_fields} as const;
        """

      {:error, error} ->
        raise "Error processing typed query #{typed_query.name}: #{inspect(error)}"
    end
  end

  defp format_fields_for_typescript(fields) do
    "[" <> format_fields_array(fields) <> "]"
  end

  defp format_fields_array(fields) do
    fields
    |> Enum.map(&format_field_item/1)
    |> Enum.join(", ")
  end

  defp format_field_item(field) when is_atom(field) do
    ~s["#{format_field_name(field)}"]
  end

  defp format_field_item({field, nested_fields}) when is_atom(field) and is_list(nested_fields) do
    # Relationship
    "{ #{format_field_name(field)}: [#{format_fields_array(nested_fields)}] }"
  end

  defp format_field_item({field, {args, nested_fields}})
       when is_atom(field) and is_map(args) and is_list(nested_fields) do
    # Calculation with args - this comes from the extraction template after processing
    args_json = format_args_map(args)

    "{ #{format_field_name(field)}: { args: #{args_json}, fields: [#{format_fields_array(nested_fields)}] } }"
  end

  defp format_field_item({field, nested_fields}) when is_atom(field) and is_map(nested_fields) do
    # Handle map structure (this might be a calculation with args and fields)
    case nested_fields do
      %{args: args, fields: fields} ->
        # Complex calculation from template
        args_json = format_args_map(args)

        "{ #{format_field_name(field)}: { args: #{args_json}, fields: [#{format_fields_array(fields)}] } }"

      _ ->
        # Other map structure - treat as generic
        inspect(nested_fields)
    end
  end

  defp format_field_item(%{} = field_map) do
    # Handle map - convert to JavaScript object syntax
    formatted_pairs =
      field_map
      |> Enum.map(fn {k, v} ->
        key = format_field_name(k)
        value = format_field_item(v)
        "#{key}: #{value}"
      end)
      |> Enum.join(", ")

    "{ #{formatted_pairs} }"
  end

  defp format_field_item(list) when is_list(list) do
    # Handle list - convert to JavaScript array syntax
    formatted_items =
      list
      |> Enum.map(&format_field_item/1)
      |> Enum.join(", ")

    "[#{formatted_items}]"
  end

  defp format_field_item(field), do: inspect(field)

  defp format_field_name(atom) do
    formatter = AshTypescript.Rpc.output_field_formatter()
    AshTypescript.FieldFormatter.format_field(atom, formatter)
  end

  defp format_args_map(args) do
    formatted_args =
      args
      |> Enum.map(fn {k, v} ->
        "\"#{format_field_name(k)}\": #{Jason.encode!(v)}"
      end)
      |> Enum.join(", ")

    "{ #{formatted_args} }"
  end
end

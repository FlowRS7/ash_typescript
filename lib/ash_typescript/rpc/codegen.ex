defmodule AshTypescript.RPC.Codegen do
  @moduledoc """
  Generates TypeScript code for interacting with Ash resources via RPC.
  """

  import AshTypescript.TS.Codegen
  import AshTypescript.TS.Filter
  import AshTypescript.Helpers

  def generate_typescript_types(otp_app, opts \\ []) do
    endpoint_process = Keyword.get(opts, :process_endpoint, "/rpc/run")
    endpoint_validate = Keyword.get(opts, :validate_endpoint, "/rpc/validate")

    resources_and_actions = get_resources_and_actions(otp_app)

    # Collect all resources from all domains
    resources =
      otp_app
      |> Ash.Info.domains()
      |> Enum.flat_map(&Ash.Domain.Info.resources/1)
      |> Enum.uniq()

    generate_full_typescript(
      resources,
      resources_and_actions,
      endpoint_process,
      endpoint_validate,
      otp_app
    )
  end

  defp get_resources_and_actions(otp_app) do
    otp_app
    |> Ash.Info.domains()
    |> Enum.flat_map(fn domain ->
      # Get RPC configuration from the domain
      rpc_config = AshTypescript.RPC.Info.rpc(domain)

      Enum.flat_map(rpc_config, fn %{resource: resource, rpc_actions: rpc_actions} ->
        Enum.map(rpc_actions, fn rpc_action ->
          action = Ash.Resource.Info.action(resource, rpc_action.action)
          {resource, action, rpc_action}
        end)
      end)
    end)
  end

  defp generate_full_typescript(
         resources,
         resources_and_actions,
         endpoint_process,
         endpoint_validate,
         otp_app
       ) do
    """
    // Generated by AshTypescript
    // Do not edit this file manually

    #{generate_type_aliases()}

    #{generate_resource_schemas(resources, otp_app)}

    #{generate_filter_types(resources)}

    #{generate_utility_types()}

    #{generate_helper_functions()}

    #{generate_rpc_functions(resources_and_actions, endpoint_process, endpoint_validate, otp_app, resources)}
    """
  end

  defp generate_utility_types do
    """
    // Utility Types
    type PickFields<T, K extends keyof T> = Pick<T, K>;

    type InferResourceResult<
      Resource extends {attributes: Record<string, any>, calculations: Record<string, any>, aggregates: Record<string, any>, relationships: Record<string, any>},
      Config extends {
        fields?: (keyof Resource["attributes"])[];
        calculatedFields?: (keyof Resource["calculations"])[];
        aggregateFields?: (keyof Resource["aggregates"])[];
        load?: Record<string, any>;
      },
    > = (Config["fields"] extends (keyof Resource["attributes"])[]
      ? PickFields<Resource["attributes"], Config["fields"][number]>
      : Resource["attributes"]) &
      (Config["calculatedFields"] extends (keyof Resource["calculations"])[]
        ? PickFields<Resource["calculations"], Config["calculatedFields"][number]>
        : {}) &
      (Config["aggregateFields"] extends (keyof Resource["aggregates"])[]
        ? PickFields<Resource["aggregates"], Config["aggregateFields"][number]>
        : {}) &
      (Config["load"] extends Record<string, any>
        ? InferRelationshipsFromMap<Config["load"], Resource["relationships"]>
        : {});

    type InferRelationshipsFromMap<LoadMap, RelationshipSchema> = {
      [K in keyof LoadMap]: LoadMap[K] extends {
        fields?: string[];
        calculatedFields?: string[];
        aggregateFields?: string[];
        load?: Record<string, any>;
      }
        ? K extends keyof RelationshipSchema
          ? RelationshipSchema[K] extends { __array: true; __resource: infer Resource }
            ? Resource extends {attributes: Record<string, any>, calculations: Record<string, any>, aggregates: Record<string, any>, relationships: Record<string, any>}
              ? Array<
                  InferResourceResult<
                    Resource,
                    {
                      fields: LoadMap[K]["fields"];
                      calculatedFields: LoadMap[K]["calculatedFields"];
                      aggregateFields: LoadMap[K]["aggregateFields"];
                      load: LoadMap[K]["load"];
                    }
                  >
                >
              : RelationshipSchema[K] extends { __resource: infer Resource }
              ? Resource extends {attributes: Record<string, any>, calculations: Record<string, any>, aggregates: Record<string, any>, relationships: Record<string, any>}
                ? InferResourceResult<
                    Resource,
                    {
                      fields: LoadMap[K]["fields"];
                      calculatedFields: LoadMap[K]["calculatedFields"];
                      aggregateFields: LoadMap[K]["aggregateFields"];
                      load: LoadMap[K]["load"];
                    }
                  >
                :never
              : never
            : never
          : never
        : never;
    };

    type InferArrayRelationshipResult<
      RelationshipType,
      Config extends {
        fields?: string[];
        calculatedFields?: string[];
        aggregateFields?: string[];
        load?: Record<string, any>;
      }
    > = RelationshipType extends { __array: true; __resource: infer Resource }
      ? Resource extends {attributes: Record<string, any>, calculations: Record<string, any>, aggregates: Record<string, any>, relationships: Record<string, any>}
        ? Array<
            InferResourceResult<
              Resource,
              {
                fields: Config["fields"];
                calculatedFields: Config["calculatedFields"];
                aggregateFields: Config["aggregateFields"];
                load: Config["load"];
              }
            >
          >
        : never
      : never;


    type LoadConfig<T> = {
      [K in keyof T]?: T[K] extends { __array: true }
        ? ArrayRelationshipConfig<T[K]>
        : RelationshipConfig<T[K]>;
    };

    type RelationshipConfig<T> = T extends {
      __resource: infer Resource;
      fields?: any;
      calculatedFields?: any;
      aggregateFields?: any;
      load?: any;
    }
      ? {
          fields?: T["fields"];
          calculatedFields?: T["calculatedFields"];
          aggregateFields?: T["aggregateFields"];
          load?: T["load"];
        }
      : never;

    type ArrayRelationshipConfig<T> = T extends {
      __array: true;
      __resource: infer Resource;
      fields?: any;
      calculatedFields?: any;
      aggregateFields?: any;
      load?: any;
    }
      ? {
          fields?: T["fields"];
          calculatedFields?: T["calculatedFields"];
          aggregateFields?: T["aggregateFields"];
          load?: T["load"];
        }
      : never;
    """
  end

  defp generate_rpc_functions(
         resources_and_actions,
         endpoint_process,
         endpoint_validate,
         otp_app,
         resources
       ) do
    # Generate relationship types for all resources
    relationship_types =
      resources
      |> Enum.map(&generate_relationship_types(&1, otp_app))
      |> Enum.join("\n\n")

    # Generate functions for each RPC action
    rpc_functions =
      resources_and_actions
      |> Enum.map(
        &generate_rpc_function(
          &1,
          resources_and_actions,
          endpoint_process,
          endpoint_validate,
          otp_app
        )
      )
      |> Enum.join("\n\n")

    """
    #{relationship_types}

    #{rpc_functions}
    """
  end

  defp generate_relationship_types(resource, _otp_app) do
    resource_name = resource |> Module.split() |> List.last()

    # Generate single relationship type
    single_rel = """
    type #{resource_name}Relationship = {
      __resource: #{resource_name}ResourceSchema;
      fields?: (keyof #{resource_name}ResourceSchema["attributes"])[];
      calculatedFields?: (keyof #{resource_name}ResourceSchema["calculations"])[];
      aggregateFields?: (keyof #{resource_name}ResourceSchema["aggregates"])[];
      load?: LoadConfig<#{resource_name}RelationshipSchema>;
    };
    """

    # Generate array relationship type
    array_rel = """
    type #{resource_name}ArrayRelationship = {
      __array: true;
      __resource: #{resource_name}ResourceSchema;
      fields?: (keyof #{resource_name}ResourceSchema["attributes"])[];
      calculatedFields?: (keyof #{resource_name}ResourceSchema["calculations"])[];
      aggregateFields?: (keyof #{resource_name}ResourceSchema["aggregates"])[];
      load?: LoadConfig<#{resource_name}RelationshipSchema>;
    };
    """

    """
    #{single_rel}

    #{array_rel}
    """
  end

  defp generate_rpc_function(
         {resource, action, rpc_action},
         _resources_and_actions,
         endpoint_process,
         _endpoint_validate,
         _otp_app
       ) do
    # Convert RPC action name to camelCase function name (e.g., read_todo -> readTodos)
    rpc_action_name = to_string(rpc_action.name)

    # Generate config type
    config_type = generate_config_type(resource, action, rpc_action_name)

    # Generate result inference type
    result_type = generate_result_type(resource, action, rpc_action_name)

    # Generate payload builder
    payload_builder = generate_payload_builder(rpc_action, action, rpc_action_name)

    # Generate RPC function
    rpc_function =
      generate_rpc_execution_function(rpc_action, action, rpc_action_name, endpoint_process)

    """
    #{config_type}

    #{result_type}

    #{payload_builder}

    #{rpc_function}
    """
  end

  defp generate_config_type(resource, action, rpc_action_name) do
    resource_name = resource |> Module.split() |> List.last()
    _function_name = snake_to_camel_case(rpc_action_name)
    config_name = "#{snake_to_pascal_case(rpc_action_name)}Config"

    # Base config fields
    base_fields = [
      "  fields?: (keyof #{resource_name}ResourceSchema[\"attributes\"])[];",
      "  calculatedFields?: (keyof #{resource_name}ResourceSchema[\"calculations\"])[];",
      "  aggregateFields?: (keyof #{resource_name}ResourceSchema[\"aggregates\"])[];",
      "  load?: LoadConfig<#{resource_name}RelationshipSchema>;"
    ]

    # Add input fields based on action type
    input_fields =
      case action.type do
        :read ->
          filters =
            if action.get? do
              []
            else
              [
                "  filter?: #{resource_name}FilterInput;"
              ]
            end

          pagination_and_sort = [
            "  sort?: string;",
            "  page?: {",
            "    limit?: number;",
            "    offset?: number;",
            "  };"
          ]

          filters ++ pagination_and_sort

        :create ->
          accepts = Ash.Resource.Info.action(resource, action.name).accept || []
          arguments = action.arguments

          input_fields =
            if accepts != [] || arguments != [] do
              ["  input: {"] ++
                Enum.map(accepts, fn field_name ->
                  attr = Ash.Resource.Info.attribute(resource, field_name)
                  optional = attr.allow_nil? || attr.default != nil
                  base_type = get_ts_type(attr)
                  field_type = if attr.allow_nil?, do: "#{base_type} | null", else: base_type

                  "    #{field_name}#{if optional, do: "?", else: ""}: #{field_type};"
                end) ++
                Enum.map(arguments, fn arg ->
                  optional = arg.allow_nil? || arg.default != nil

                  "    #{arg.name}#{if optional, do: "?", else: ""}: #{get_ts_type(arg)};"
                end) ++
                ["  };"]
            else
              []
            end

          input_fields

        action_type when action_type in [:update, :destroy] ->
          primary_key_attrs = Ash.Resource.Info.primary_key(resource)

          primary_key_field =
            if Enum.count(primary_key_attrs) == 1 do
              attr_name = Enum.at(primary_key_attrs, 0)
              attr = Ash.Resource.Info.attribute(resource, attr_name)
              ["  primaryKey: #{get_ts_type(attr)};"]
            else
              ["  primaryKey: {"] ++
                Enum.map(primary_key_attrs, fn attr_name ->
                  attr = Ash.Resource.Info.attribute(resource, attr_name)
                  "    #{attr.name}: #{get_ts_type(attr)};"
                end) ++
                ["  };"]
            end

          input_fields =
            if action.accept != [] || action.arguments != [] do
              ["  input: {"] ++
                Enum.map(action.accept, fn field_name ->
                  attr = Ash.Resource.Info.attribute(resource, field_name)

                  if attr.allow_nil? do
                    "    #{field_name}?: #{get_ts_type(attr)} | null;"
                  else
                    "    #{field_name}: #{get_ts_type(attr)};"
                  end
                end) ++
                Enum.map(action.arguments, fn arg ->
                  optional = arg.allow_nil? || arg.default != nil

                  "    #{arg.name}#{if optional, do: "?", else: ""}: #{get_ts_type(arg)};"
                end) ++
                ["  };"]
            else
              []
            end

          primary_key_field ++ input_fields

        :action ->
          arguments = action.arguments

          if arguments != [] do
            ["  input: {"] ++
              Enum.map(arguments, fn arg ->
                optional = arg.allow_nil? || arg.default != nil

                "    #{arg.name}#{if optional, do: "?", else: ""}: #{get_ts_type(arg)};"
              end) ++
              ["  };"]
          else
            []
          end
      end

    all_fields =
      if action.type in [:read, :create, :update] do
        input_fields ++ base_fields
      else
        input_fields
      end

    """
    export type #{config_name} = {
    #{Enum.join(all_fields, "\n")}
    };
    """
  end

  defp generate_result_type(resource, action, rpc_action_name) do
    resource_name = resource |> Module.split() |> List.last()
    _function_name = snake_to_camel_case(rpc_action_name)

    rpc_action_name_pascal = snake_to_pascal_case(rpc_action_name)

    case action.type do
      :read when action.get? ->
        """
        type Infer#{rpc_action_name_pascal}Result<Config extends #{rpc_action_name_pascal}Config> =
          InferResourceResult<#{resource_name}ResourceSchema, Config> | null;
        """

      :read ->
        """
        type Infer#{rpc_action_name_pascal}Result<Config extends #{rpc_action_name_pascal}Config> =
          Array<InferResourceResult<#{resource_name}ResourceSchema, Config>>;
        """

      action_type when action_type in [:create, :update] ->
        """
        type Infer#{rpc_action_name_pascal}Result<Config extends #{rpc_action_name_pascal}Config> =
          InferResourceResult<#{resource_name}ResourceSchema, Config>;
        """

      :destroy ->
        """
        type Infer#{rpc_action_name_pascal}Result = void;
        """

      action_type when action_type in [:action, :generic] ->
        # For generic actions, use the returns type if specified
        if action.returns do
          return_type = get_ts_type(%{type: action.returns, constraints: action.constraints})

          """
          type Infer#{rpc_action_name_pascal}Result = #{return_type};
          """
        else
          """
          type Infer#{rpc_action_name_pascal}Result = any;
          """
        end
    end
  end

  defp generate_payload_builder(_rpc_action, action, rpc_action_name) do
    rpc_action_name_pascal = snake_to_pascal_case(rpc_action_name)

    cond do
      action.type == :read and not action.get? ->
        """
        export function build#{rpc_action_name_pascal}Payload(
          config: #{rpc_action_name_pascal}Config
        ): Record<string, any> {
          const payload: Record<string, any> = {
            action: "#{rpc_action_name}"
          };

          // Add select fields
          if (config.fields) {
            payload.select = config.fields;
          } else {
            payload.select = [];
          }

          payload.load = [];

          if (config.calculatedFields) {
            payload.load.push(...config.calculatedFields);
          }

          if (config.aggregateFields) {
            payload.load.push(...config.aggregateFields);
          }

          // Build load array from load configuration
          if (config.load) {
            const loads = buildLoadArray(config.load);
            payload.load.push(...loads);
          }

          if (config.filter) {
            payload.filter = config.filter;
          } else {
            payload.filter = {};
          }

          if (config.page) {
            payload.page = config.page;
          }

          if (config.sort) {
            payload.sort = config.sort;
          }

          if ("input" in config && config.input) {
            payload.input = config.input;
          } else {
            payload.input = {};
          }

          return payload;
        }
        """

      action.type == :read and action.get? ->
        """
        export function build#{rpc_action_name_pascal}Payload(
          config: #{rpc_action_name_pascal}Config
        ): Record<string, any> {
          const payload: Record<string, any> = {
            action: "#{rpc_action_name}"
          };

          // Add select fields
          if (config.fields) {
            payload.select = config.fields;
          } else {
            payload.select = [];
          }

          // Build load array from load configuration
          if (config.load) {
            payload.load = buildLoadArray(config.load);
          } else {
            payload.load = [];
          }

          if ("input" in config && config.input) {
            payload.input = config.input;
          } else {
            payload.input = {};
          }

          return payload;
        }
        """

      action.type == :create ->
        """
        export function build#{rpc_action_name_pascal}Payload(
          config: #{rpc_action_name_pascal}Config
        ): Record<string, any> {
          const payload: Record<string, any> = {
            action: "#{rpc_action_name}"
          };

          // Add select fields
          if (config.fields) {
            payload.select = config.fields;
          } else {
            payload.select = [];
          }

          // Build load array from load configuration
          if (config.load) {
            payload.load = buildLoadArray(config.load);
          } else {
            payload.load = [];
          }

          if ("input" in config && config.input) {
            payload.input = config.input;
          } else {
            payload.input = {};
          }

          return payload;
        }
        """

      action.type == :update ->
        """
        export function build#{rpc_action_name_pascal}Payload(
          config: #{rpc_action_name_pascal}Config
        ): Record<string, any> {
          const payload: Record<string, any> = {
            action: "#{rpc_action_name}"
          };

          if (config.primaryKey) {
            payload.primary_key = config.primaryKey;
          }

          if ("input" in config && config.input) {
            payload.input = config.input;
          } else {
            payload.input = {};
          }

          // Add select fields
          if (config.fields) {
            payload.select = config.fields;
          } else {
            payload.select = [];
          }

          // Build load array from load configuration
          if (config.load) {
            payload.load = buildLoadArray(config.load);
          } else {
            payload.load = [];
          }

          return payload;
        }
        """

      action.type == :destroy ->
        """
        export function build#{rpc_action_name_pascal}Payload(
          config: #{rpc_action_name_pascal}Config
        ): Record<string, any> {
          const payload: Record<string, any> = {
            action: "#{rpc_action_name}"
          };

          if (config.primaryKey) {
            payload.primary_key = config.primaryKey;
          }

          if ("input" in config && config.input) {
            payload.input = config.input;
          } else {
            payload.input = {};
          }

          return payload;
        }
        """

      action.type == :action ->
        """
        export function build#{rpc_action_name_pascal}Payload(
          config: #{rpc_action_name_pascal}Config
        ): Record<string, any> {
          const payload: Record<string, any> = {
            action: "#{rpc_action_name}"
          };

          if ("input" in config && config.input) {
            payload.input = config.input;
          } else {
            payload.input = {};
          }

          return payload;
        }
        """
    end
  end

  defp generate_rpc_execution_function(_rpc_action, action, rpc_action_name, endpoint_process) do
    function_name = snake_to_camel_case(rpc_action_name)

    # Add proper type handling for different action types
    is_generic_action = action.type in [:action, :generic]

    rpc_action_name_pascal = snake_to_pascal_case(rpc_action_name)

    result_handling =
      case action.type do
        :destroy ->
          "return;"

        _ when is_generic_action ->
          "return result.data as Infer#{rpc_action_name_pascal}Result;"

        _ ->
          "return result.data as Infer#{rpc_action_name_pascal}Result<Config>;"
      end

    {config_type_param, config_param} =
      case action.type do
        :destroy -> {"", "config: #{rpc_action_name_pascal}Config"}
        _ when is_generic_action -> {"", "config: #{rpc_action_name_pascal}Config"}
        _ -> {"<Config extends #{rpc_action_name_pascal}Config>", "config: Config"}
      end

    result_type =
      case action.type do
        :destroy -> "void"
        _ when is_generic_action -> "Infer#{rpc_action_name_pascal}Result"
        _ -> "Infer#{rpc_action_name_pascal}Result<Config>"
      end

    """
    export async function #{function_name}#{config_type_param}(
      #{config_param}
    ): Promise<#{result_type}> {
      const payload = build#{rpc_action_name_pascal}Payload(config);

      const csrfToken = document
        ?.querySelector("meta[name='csrf-token']")
        ?.getAttribute("content");

      const headers: Record<string, string> = {
        "Content-Type": "application/json",
      };

      if (csrfToken) {
        headers["X-CSRF-Token"] = csrfToken;
      }

      const response = await fetch("#{endpoint_process}", {
        method: "POST",
        headers,
        body: JSON.stringify(payload),
      });

      if (!response.ok) {
        throw new Error(`RPC call failed: ${response.statusText}`);
      }

      const result = await response.json();
      #{result_handling}
    }
    """
  end

  defp generate_helper_functions do
    """
    // Helper function to build load arrays from load configuration
    function buildLoadArray(loadConfig: any): any[] {
      const result: any[] = [];

      for (const [key, value] of Object.entries(loadConfig)) {
        if (value && typeof value === 'object') {
          const loadItem: any = { [key]: [] };

          if ('fields' in value && value.fields) {
            loadItem[key] = value.fields;
          }

          if ('load' in value && value.load) {
            const nestedLoad = buildLoadArray(value.load);
            if (nestedLoad.length > 0) {
              loadItem[key] = [...(loadItem[key] || []), ...nestedLoad];
            }
          }

          result.push(loadItem);
        } else if (value === true) {
          result.push(key);
        }
      }

      return result;
    }
    """
  end
end
